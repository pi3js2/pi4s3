module pi4s3_to_bool where

-- Section: prelude

-- this is all copied from brunerie3.ctt, and maybe other files, so
-- presumably written by Mörtberg, Cavallo, and maybe other cubicaltt
-- contributors (?)

-- basics

Path (A : U) (a0 a1 : A) : U = PathP (<i> A) a0 a1

refl (A : U) (a : A) : Path A a a = <i> a

compPath (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c =
  <i> hcomp A (p @ i) [ (i =0) -> <j> a, (i = 1) -> q ]

idfun (A : U) (a : A) : A = a

Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (Path A (u @ i) (v @ i))) r0 r1

Sigma (A : U) (B : A -> U) : U = (x : A) * B x

fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)
isContr (A : U) : U = (x : A) * ((y : A) -> Path A x y)
prop (A : U) : U = (a b : A) -> Path A a b
set (A : U) : U = (a b : A) -> prop (Path A a b)

isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)

equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

contrSingl (A : U) (a b : A) (p : Path A a b) :
  Path ((x : A) * Path A a x) (a,<_>a) (b,p) = <i> (p @ i,<j> p @ i/\j)

idIsEquiv (A : U) : isEquiv A A (idfun A) =
  \(a : A) -> ((a,<_>a),\(z : (x : A) * Path A a x) -> contrSingl A a z.1 z.2)

idEquiv (A : U) : equiv A A = (idfun A,idIsEquiv A)

ua (A B : U) (e : equiv A B) : Path U A B =
  <i> Glue B [ (i = 0) -> (A,e)
             , (i = 1) -> (B,idEquiv B) ]

isContrIdIsEquiv (A : U) : isContr (isEquiv A A (idfun A)) = (idIsEquiv A,goal)
  where
  goal (q : isEquiv A A (idfun A)) : Path (isEquiv A A (idfun A)) (idIsEquiv A) q =
    <i> \(y : A) -> (((q y).1.2 @ i,<j> (q y).1.2 @ i /\ j)
       ,\(w : (x : A) * Path A y x) ->
         <j> (hcomp A (w.2 @ i \/ j)
                      [(i=0) -> <_> w.2 @ j
                      ,(i=1) -> <k> ((q y).2 w @ j \/ -k).1
                      ,(j=0) -> <k> ((q y).2 w @ -k).2 @ i
                      ,(j=1) -> <_> w.1]
             ,<k> hcomp A (w.2 @ (i \/ j) /\ k)
                          [(i=0) -> <_> w.2 @ j /\ k
                          ,(i=1) -> <l> ((q y).2 w @ j \/ -l).2 @ k
                          ,(j=0) -> <l> ((q y).2 w @ -l).2 @ i /\ k
                          ,(j=1) -> <_> w.2 @ k
                          ,(k=0) -> <_> y
                          ,(k=1) -> <l> hfill A (w.2 @ i \/ j)
                                                [(i=0) -> <_> w.2 @ j
                                                ,(i=1) -> <k> ((q y).2 w @ j \/ -k).1
                                                ,(j=0) -> <k> ((q y).2 w @ -k).2 @ i
                                                ,(j=1) -> <_> w.1] @ l]))

propIsEquivDirect' (A B : U) (f : A -> B) : prop (isEquiv A B f) =
  \(p q : isEquiv A B f) ->
  <i> \(y : B) ->
    let p0 : A = (p y).1.1
        p1 : Path B y (f p0) = (p y).1.2
        p2 : (w1 : fiber A B f y) -> Path (fiber A B f y) (p0,p1) w1 =
         (p y).2
        q0 : A = (q y).1.1
        q1 : Path B y (f q0) = (q y).1.2
        q2 : (w1 : fiber A B f y) -> Path (fiber A B f y) (q0,q1) w1 =
         (q y).2
        alpha : Path (fiber A B f y) (p0,p1) (q0,q1) = p2 (q y).1
    in (alpha @ i,
       \(w : fiber A B f y) ->
          let x : A = w.1
              wx : Path B y (f x) = w.2
              alpha1 : Path A p0 q0 = <i> (alpha @ i).1
              alpha2 : PathP (<i> Path B y (f (alpha1 @ i))) p1 q1 =
                <i> (alpha @ i).2
              p2w1 : Path A p0 x = <i> (p2 w @ i).1
              q2w1 : Path A q0 x = <i> (q2 w @ i).1
              p2w2 : PathP (<i> Path B y (f (p2w1 @ i))) p1 wx = <i> (p2 w @ i).2
              q2w2 : PathP (<i> Path B y (f (q2w1 @ i))) q1 wx = <i> (q2 w @ i).2
              sq1 : PathP (<j> Path A (alpha1 @ j) x) p2w1 q2w1 =
                    <i j> hcomp A (p2w1 @ i \/ j)
                                 [ (i = 0) -> <k> p2w1 @ j
                                 , (i = 1) -> <k> q2w1 @ j \/ -k
                                 , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).1
                                 , (j = 1) -> <k> x ]
              sq2 : PathP (<i> PathP (<j> Path B y (f (sq1 @ i @ j)))
                                     (alpha2 @ i) wx)
                          p2w2 q2w2 =
                     <i j l> hcomp B (p2w2 @ i \/ j @ l)
                                 [ (i = 0) -> <k> p2w2 @ j @ l
                                 , (i = 1) -> <k> q2w2 @ j \/ -k @ l
                                 , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).2 @ l
                                 , (j = 1) -> <k> wx @ l
                                 , (l = 0) -> <k> y
                                 , (l = 1) -> <k> f (hfill A (p2w1 @ i \/ j)
                                                        [ (i = 0) -> <k> p2w1 @ j
                                                        , (i = 1) -> <k> q2w1 @ j \/ -k
                                                        , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).1
                                                        , (j = 1) -> <k> x ] @ k)
                                 ]
          in <j> (sq1 @ i @ j,sq2 @ i @ j))

subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transGen (<i> P (p @ i)) 0 e

J (A : U) (a : A) (C : (x : A) -> Path A a x -> U)
  (d : C a (<_> a)) (x : A) (p : Path A a x) : C x p =
    subst ((x : A) * Path A a x) T (a,<_> a) (x, p) (contrSingl A a x p) d
      where T (z : (x : A) * Path A a x) : U = C (z.1) (z.2)

-- hedberg (still from brunerie3.ctt)

data N0 =

not (A : U) : U = A -> N0
efq (A : U) : N0 -> A = split {}

data or (A B : U) = inl (a : A)
                  | inr (b : B)

data Unit = tt

stable (A : U) : U = not (not A) -> A
const (A : U) (f : A -> A) : U = (x y : A) -> Path A (f x) (f y)

exConst (A : U) : U = (f:A -> A) * const A f
propN0 : prop N0 = \ (x y:N0) -> efq (Path N0 x y) x

propNot (A : U) : prop (not A) = \ (f g:not A) -> <i>\(x:A) -> (propN0 (f x) (g x))@i

dNot (A : U) (a : A) : not (not A) = \ (h : not A) -> h a

stableConst (A : U) (sA : stable A) : exConst A =
 (\ (x:A) -> sA (dNot A x),\ (x y:A) -> <i>sA (propNot (not A) (dNot A x) (dNot A y) @ i))

dec (A : U) : U = or A (not A)

decEqCong (A B : U) (f : A -> B) (g : B -> A) : dec A -> dec B = split
  inl a -> inl (f a)
  inr h -> inr (\ (b:B) -> h (g b))

decStable (A : U) : dec A -> stable A = split
 inl a -> \ (h :not (not A)) -> a
 inr b -> \ (h :not (not A)) -> efq A (h b)

discrete (A : U) : U = (a b : A) -> dec (Path A a b)

hedbergLemma (A: U) (a b:A) (f : (x : A) -> Path A a x -> Path A a x) (p : Path A a b) :
            Square A a a a b (<_> a) p (f a (<_> a)) (f b p) = <i> f (p @ i) (<j> p @ i /\ j)

hedbergStable (A : U) (a b : A) (h : (x : A) -> stable (Path A a x))
        (p q : Path A a b) : Path (Path A a b) p q =
 <j i> hcomp A a [ (j = 0) -> rem2 @ i
                 , (j = 1) -> rem3 @ i
                 , (i = 0) -> r
                 , (i = 1) -> rem4 @ j]
 where
   rem1 (x : A) : exConst (Path A a x) = stableConst (Path A a x) (h x)
   f (x : A) : Path A a x -> Path A a x  = (rem1 x).1
   fIsConst (x : A) : const (Path A a x) (f x) = (rem1 x).2
   rem4 : Square A a a b b (<_> a) (<_> b) (f b p) (f b q)  = fIsConst b p q
   r : Path A a a = f a (<_> a)
   rem2 : Square A a a a b (<_> a) p r (f b p) = hedbergLemma A a b f p
   rem3 : Square A a a a b (<_> a) q r (f b q) = hedbergLemma A a b f q

hedberg (A : U) (h : discrete A) : set A =
 \(a b : A) -> hedbergStable A a b (\(b : A) -> decStable (Path A a b) (h a b))

-- booleans

data bool = false | true

negb : bool -> bool = split
  false -> true
  true -> false

negbNegb : (b : bool) -> Path bool b (negb (negb b)) = split
  false -> <_> false
  true -> <_> true

TODO_isEquivNegb : (b : bool) (y : fiber bool bool negb b) -> Path (fiber bool bool negb b) (negb b, negbNegb b) y
  -- TODO easy
  = undefined

isEquivNegb : isEquiv bool bool negb = \(b : bool) -> ((negb b, negbNegb b), TODO_isEquivNegb b)

negbEquiv : equiv bool bool = (negb, isEquivNegb)

negbPath : Path U bool bool = ua bool bool negbEquiv

discreteBool : discrete bool
  -- TODO easy
  = undefined

setBool : set bool
  = hedberg bool discreteBool

-- nats and ints (still from brunerie3.ctt)

data nat = zero | suc (n : nat)

pred : nat -> nat = split
  zero -> zero
  suc n -> n

data Z = pos (n : nat) | neg (n : nat)

zeroZ : Z = pos zero

caseNat (A : U) (a0 aS : A) : nat -> A = split
 zero -> a0
 suc n -> aS

caseDNat (P:nat -> U) (a0 :P zero) (aS : (n:nat) -> P (suc n))
            : (n:nat) -> P n = split
 zero -> a0
 suc n -> aS n

znots (n : nat) : not (Path nat zero (suc n)) =
  \(h : Path nat zero (suc n)) -> subst nat (caseNat U nat N0) zero (suc n) h zero

snotz (n : nat) : not (Path nat (suc n) zero) =
  \(h : Path nat (suc n) zero) -> znots n (<i> h @ -i)

sucInj (n m : nat) (p : Path nat (suc n) (suc m)) : Path nat n m =
 <i> pred (p @ i)

discreteNat : discrete nat = split
 zero -> caseDNat (\(m : nat) -> dec (Path nat zero m)) (inl (<_> zero)) (\(m : nat) -> inr (znots m))
 suc n -> caseDNat (\(m : nat) -> dec (Path nat (suc n) m)) (inr (snotz n))
   (\(m : nat) -> decEqCong (Path nat n m) (Path nat (suc n) (suc m)) (\(p : Path nat n m) -> <i> suc (p @ i))
                  (sucInj n m) (discreteNat n m))

posNotneg (a b : nat) (h : Path Z (pos a) (neg b)) : N0 = subst Z T (pos a) (neg b) h tt
  where
  T : Z -> U = split
       pos _ -> Unit
       neg _ -> N0

negNotpos (a b : nat) (h : Path Z (neg b) (pos a)) : N0 = subst Z T (neg b) (pos a) h tt
  where
  T : Z -> U = split
       pos _ -> N0
       neg _ -> Unit

injPos (a b : nat) (h : Path Z (pos a) (pos b)) : Path nat a b =
 subst Z T (pos a) (pos b) h (<_> a)
 where
   T : Z -> U = split
        pos c -> Path nat a c
        neg _ -> N0

injNeg (a b : nat) (h : Path Z (neg a) (neg b)) : Path nat a b =
  subst Z T (neg a) (neg b) h (<_> a)
  where
    T : Z -> U = split
         pos _ -> N0
         neg c -> Path nat a c

discreteZ : discrete Z = split
  pos a -> split@((z1 : Z) -> dec (Path Z (pos a) z1)) with
             pos a1 -> let rem : dec (Path nat a a1) -> dec (Path Z (pos a) (pos a1)) = split
                             inl p -> inl (<i> pos (p @ i))
                             inr h -> inr (\(p : Path Z (pos a) (pos a1)) -> h (injPos a a1 p))
                       in rem (discreteNat a a1)
             neg b -> inr (posNotneg a b)
  neg b -> split@((z1 : Z) -> dec (Path Z (neg b) z1)) with
             pos a -> inr (negNotpos a b)
             neg b1 -> let rem : dec (Path nat b b1) -> dec (Path Z (neg b) (neg b1)) = split
                             inl p -> inl (<i> neg (p @ i))
                             inr h -> inr (\(p : Path Z (neg b) (neg b1)) -> h (injNeg b b1 p))
                       in rem (discreteNat b b1)

ZSet : set Z = hedberg Z discreteZ

predZ : Z -> Z = split
  pos u -> auxpredZ u
    where
    auxpredZ : nat -> Z = split
      zero  -> neg zero
      suc n -> pos n
  neg v -> neg (suc v)

sucZ : Z -> Z = split
  pos u -> pos (suc u)
  neg v -> auxsucZ v
    where
    auxsucZ : nat -> Z = split
      zero  -> pos zero
      suc n -> neg n

predsucZ : (x : Z) -> Path Z (predZ (sucZ x)) x = split
  pos u -> <_> pos u
  neg v -> lem v
   where
    lem : (u : nat) -> Path Z (predZ (sucZ (neg u))) (neg u) = split
      zero  -> <_> neg zero
      suc n -> <_> neg (suc n)

sucpredZ : (x : Z) -> Path Z (sucZ (predZ x)) x = split
  pos u -> lem u
   where
    lem : (u : nat) -> Path Z (sucZ (predZ (pos u))) (pos u) = split
      zero  -> <_> pos zero
      suc n -> <_> pos (suc n)
  neg v -> <_> neg v

gengoal (A : U) (hA : set A) (x y : A) (p : Path A x y) : (z : A) (r : Path A y z) (q : Path A x z) ->
  PathP (<i> Path A x (r @ i)) p q =
  J A y (\(z : A) (r : Path A y z) -> (q : Path A x z) -> PathP (<i> Path A x (r @ i)) p q)
   (hA x y p)

ctr (y : Z) : fiber Z Z sucZ y = (predZ y,<i> sucpredZ y @ -i)

contr (y : Z) (y' : fiber Z Z sucZ y) : Path ((x : Z) * Path Z y (sucZ x)) (ctr y) y' =
    let p1 : Path Z (predZ y) y'.1 =
          compPath Z (predZ y) (predZ (sucZ y'.1)) y'.1
                   (<i> predZ (y'.2 @ i)) (predsucZ y'.1)
        prf1 : Path Z (sucZ (predZ y)) (sucZ y'.1) = <i> sucZ (p1 @ i)
        prf2 : Path Z y (sucZ (predZ y)) = <i> sucpredZ y @ -i
        p2 : PathP (<i> Path Z y (prf1 @ i)) prf2 y'.2 =
          gengoal Z ZSet y (sucZ (predZ y)) prf2 (sucZ y'.1) prf1 y'.2
    in <i> (p1 @ i,p2 @ i)

equivSucZ : isEquiv Z Z sucZ = \(y : Z) -> (ctr y,contr y)

sucPathZ : Path U Z Z = ua Z Z (sucZ,equivSucZ)



-- Section: some hlevel stuff

-- copied from brunerie3.ctt <3

propSet (A : U) (h : prop A) : set A =
 \(a b : A) (p q : Path A a b) ->
   <j i> hcomp A a [ (i=0) -> h a a
                       , (i=1) -> h a b
                       , (j=0) -> h a (p @ i)
                       , (j=1) -> h a (q @ i)]

propIsProp (A : U) : prop (prop A) =
  \(f g : prop A) -> <i> \(a b : A) ->
    propSet A f a b (f a b) (g a b) @ i

setIsProp (A : U) : prop (set A) =
 \(f g : set A) -> <i> \(a b :A) ->
   propIsProp (Path A a b) (f a b) (g a b) @ i

retract (A B : U) (f : A -> B) (g : B -> A) : U =
  (a : A) -> Path A (g (f a)) a

retractProp (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g) (pB : prop B) (x y : A)
  : Path A x y =
  <i> hcomp A (g (pB (f x) (f y) @ i)) [ (i=0) -> rfg x , (i=1) -> rfg y ]

retractInv (A B : U)  (f : A -> B) (g : B -> A) (rfg : retract A B f g)
  (x y : A) (q : Path B (f x) (f y)) : Path A x y =
    <i> hcomp A (g (q @ i)) [(i = 0) -> rfg x, (i = 1) -> rfg y]

retractPath (A B : U)(f : A -> B) (g : B -> A) (rfg : retract A B f g) (x y :A) (p:Path A x y) :
  Path (Path A x y) (retractInv A B f g rfg x y (<i> f (p@ i))) p =
    <j i> hcomp A (rfg (p @ i) @ j)
       [ (i = 0) -> <k> rfg x @ (j \/ k)
       , (i = 1) -> <k> rfg y @ (j \/ k)
       , (j = 1) -> <k> rfg (p @ i) @ 1
       ]

retractSet (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
  (sB : set B) (x y : A) : prop (Path A x y) =
  retractProp (Path A x y) (Path B (f x) (f y)) (\(p : Path A x y) -> <i> f (p @ i))
              (retractInv A B f g rfg x y) (retractPath A B f g rfg x y) (sB (f x) (f y))

setSigProp (A:U) (B:A -> U) (pB : (x:A) -> prop (B x))
  (sA : (t u : Sigma A B) -> prop (Path A t.1 u.1)) (t u : Sigma A B)
  : prop (Path (Sigma A B) t u) =
  retractProp T0 T1 f g ret (sA t u)
  where
  T0 : U = Path (Sigma A B) t u
  T1 : U = Path A t.1 u.1

  f (p : T0) : T1 = <i> (p @ i).1
  g (q : T1) : T0 = <i>
    ( q @ i
    , hcomp (B (q @ i)) (transGen (<k> B (q @ i /\ k)) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (q @ i /\ k)) 0 t.2) u.2
      ]
    )

  ret (p : T0) : Path T0 (g (f p)) p = <j i>
    ( (p @ i).1
    , hcomp (B (p @ i).1) (transGen (<k> B (p @ i /\ k).1) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (p @ i /\ k).1) 0 t.2) u.2
      , (j=1) -> pB (p @ i).1 (transGen (<k> B (p @ i /\ k).1) (-i) t.2) (p @ i).2
      ]
    )

groupoidSigProp (A:U) (B:A -> U) (pB : (x:A) -> prop (B x))
  (sA : (t u : Sigma A B) -> set (Path A t.1 u.1)) (t u : Sigma A B)
  : set (Path (Sigma A B) t u) =
  retractSet T0 T1 f g ret (sA t u)
  where
  T0 : U = Path (Sigma A B) t u
  T1 : U = Path A t.1 u.1

  f (p : T0) : T1 = <i> (p @ i).1
  g (q : T1) : T0 = <i>
    ( q @ i
    , hcomp (B (q @ i)) (transGen (<k> B (q @ i /\ k)) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (q @ i /\ k)) 0 t.2) u.2
      ]
    )

  ret (p : T0) : Path T0 (g (f p)) p = <j i>
    ( (p @ i).1
    , hcomp (B (p @ i).1) (transGen (<k> B (p @ i /\ k).1) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (p @ i /\ k).1) 0 t.2) u.2
      , (j=1) -> pB (p @ i).1 (transGen (<k> B (p @ i /\ k).1) (-i) t.2) (p @ i).2
      ]
    )

groupoid (A : U) : U = (a b : A) -> set (Path A a b)
twogroupoid (A : U) : U = (a b : A) -> groupoid (Path A a b)
threegroupoid (A : U) : U = (a b : A) -> twogroupoid (Path A a b)

groupoidIsProp (A : U) : prop (groupoid A) =
 \(f g : groupoid A) -> <i> \(a b :A) ->
   setIsProp (Path A a b) (f a b) (g a b) @ i

retractGroupoid (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
           (sB : groupoid B) (x y : A) : set (Path A x y) =
  retractSet (Path A x y) (Path B (f x) (f y)) (\(p : Path A x y) -> <i> f (p @ i))
              (retractInv A B f g rfg x y) (retractPath A B f g rfg x y) (sB (f x) (f y))

twogroupoidSigProp (A:U) (B:A -> U) (pB : (x:A) -> prop (B x))
  (sA : (t u : Sigma A B) -> groupoid (Path A t.1 u.1)) (t u : Sigma A B)
  : groupoid (Path (Sigma A B) t u) =
  retractGroupoid T0 T1 f g ret (sA t u)
  where
  T0 : U = Path (Sigma A B) t u
  T1 : U = Path A t.1 u.1

  f (p : T0) : T1 = <i> (p @ i).1
  g (q : T1) : T0 = <i>
    ( q @ i
    , hcomp (B (q @ i)) (transGen (<k> B (q @ i /\ k)) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (q @ i /\ k)) 0 t.2) u.2
      ]
    )

  ret (p : T0) : Path T0 (g (f p)) p = <j i>
    ( (p @ i).1
    , hcomp (B (p @ i).1) (transGen (<k> B (p @ i /\ k).1) (-i) t.2)
      [ (i=0) -> pB t.1 t.2 t.2
      , (i=1) -> pB u.1 (transGen (<k> B (p @ i /\ k).1) 0 t.2) u.2
      , (j=1) -> pB (p @ i).1 (transGen (<k> B (p @ i /\ k).1) (-i) t.2) (p @ i).2
      ]
    )

setGroupoid (A : U) (h : set A) : groupoid A
  = \(x y : A) -> propSet (Path A x y) (h x y)

groupoidTwogroupoid (A : U) (h : groupoid A) : twogroupoid A
  = \(x y : A) -> setGroupoid (Path A x y) (h x y)

pi (A:U) (P:A->U) : U = (x:A) -> P x

setPi (A:U) (B:A -> U) (h:(x:A) -> set (B x)) (f g : pi A B) : prop (Path (pi A B) f g) =
  \(p q : Path (pi A B) f g) ->
  <j i> \(a : A) -> h a (f a) (g a) (<i> p @ i a) (<i> q @ i a) @ j @ i

setFun (A B : U) (sB : set B) : set (A -> B) =
 setPi A (\(x : A) -> B) (\(x : A) -> sB)

transEquiv' (A X : U) (p : Path U X A) : equiv X A =
  subst U (\(Y : U) -> equiv Y A) A X (<i> p @ -i) (idEquiv A)

uaRetraction (A X : U) (p : Path U X A) : Path (Path U X A) (ua X A (transEquiv' A X p)) p =
  <j i>
  Glue A
    [ (i=0) -> (X, transEquiv' A X p)
    , (i=1) -> (A, idEquiv A)
    , (j=1) -> (p @ i, transGen (<k> equiv (p @ -k \/ i) A) i (idEquiv A))
    ]

setPath (A B : U) (sB : set B) : set (Path U A B) =
  retractSet (Path U A B) (equiv A B) (transEquiv' B A) (ua A B) (uaRetraction B A) rem
  where
  rem : set (equiv A B) =
    setSigProp (A -> B) (isEquiv A B) (propIsEquivDirect' A B)
      (\(E F : equiv A B) -> setFun A B sB E.1 F.1)

SET : U = (A : U) * set A

GROUPOID : U = (A : U) * groupoid A

groupoidSET : groupoid SET =
  groupoidSigProp U set setIsProp (\(A B : SET) -> setPath A.1 B.1 B.2)

opaque groupoidSET

groupoidPi (A : U) (B : A -> U) (h : (x : A) -> groupoid (B x)) (f g : pi A B) : set (Path (pi A B) f g) =
  \(p q : Path (pi A B) f g) ->
  \(r s : Path (Path (pi A B) f g) p q) ->
  <k j i> \(a : A) ->
  h a (f a) (g a) (<i> p @ i a) (<i> q @ i a) (<j i> r @ j @ i a) (<j i> s @ j @ i a) @ k @ j @ i

groupoidFun (A B : U) (sB : groupoid B) : groupoid (A -> B) =
  groupoidPi A (\(x : A) -> B) (\(x : A) -> sB)

groupoidPath (A B : U) (sB : groupoid B) : groupoid (Path U A B) =
  retractGroupoid (Path U A B) (equiv A B) (transEquiv' B A) (ua A B) (uaRetraction B A) rem
  where
  rem : groupoid (equiv A B) =
    groupoidSigProp (A -> B) (isEquiv A B) (propIsEquivDirect' A B)
      (\(E F : equiv A B) -> groupoidFun A B sB E.1 F.1)

twogroupoidGROUPOID : twogroupoid GROUPOID =
  twogroupoidSigProp U groupoid groupoidIsProp (\(A B : GROUPOID) -> groupoidPath A.1 B.1 B.2)

opaque twogroupoidGROUPOID

TWOGROUPOID : U = (A : U) * twogroupoid A

threegroupoidTWOGROUPOID : threegroupoid TWOGROUPOID
  -- TODO ugh
  = undefined

opaque twogroupoidGROUPOID



-- Section: Truncation

lemPropF' (A : U) (P : A -> U) (pP : (x : A) -> prop (P x)) (a0 a1 : A)
          (p : Path A a0 a1) (b0 : P a0) (b1 : P a1) : PathP (<i>P (p@i)) b0 b1 =
 transGen (<k> (b0 : P a0) (b1 : P (p @ k)) -> PathP (<i> P (p @ i /\ k)) b0 b1)
          0
          (pP a0) b0 b1

-- prop truncation
data inh (A : U)
  = inc (x : A)
  | squash (x y : inh A) <i>
      [ (i=0) -> x
      , (i=1) -> y
      ]

recInh (A B : U) (lev : prop B) (f : A -> B) : inh A -> B = split
  inc x -> f x
  squash x y @ i -> lev (recInh A B lev f x) (recInh A B lev f y) @ i

elimInh (A : U) (B : inh A -> U) (lev : (x : inh A) -> prop (B x))
  (f : (x : A) -> B (inc x))
  : (x : inh A) -> B x = split
  inc x -> f x
  squash x y @ i ->
    lemPropF' (inh A) B lev x y (<i> squash{inh A} x y @ i) (elimInh A B lev f x) (elimInh A B lev f y) @ i

propInh (A : U) : prop (inh A) =
  \(x y : inh A) -> <i> squash{inh A} x y @ i

mapInh (A B : U) (f : A -> B) : inh A -> inh B
  = recInh A (inh B) (propInh B) (\(x : A) -> inc (f x))

data tr0 (A : U)
  = inc (x : A)
  | squash
      (x y : tr0 A)
      (p q : Path (tr0 A) x y)
      <i j>
      [ (i=0) -> p @ j
      , (i=1) -> q @ j
      , (j=0) -> x
      , (j=1) -> y
      ]

recTr0 (A B : U) (lev : set B) (f : A -> B) : tr0 A -> B = split
  inc x -> f x
  squash x y p q @ i j ->
    lev
      (rec x)
      (rec y)
      (<j> rec (p @ j))
      (<j> rec (q @ j))
      @ i @ j
    where
    rec : tr0 A -> B = recTr0 A B lev f

elimTr0 (A : U) (B : tr0 A -> U)
  (lev : (x : tr0 A) -> groupoid (B x))
  (f : (x : A) -> B (inc x))
  : (x : tr0 A) -> B x = split
  inc x -> f x
  squash x y p q @ i j -> TODO @ i @ j
    where
    elim : (x : tr0 A) -> B x = elimTr0 A B lev f

    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> B (squash{tr0 A} x y p q @ i @ j))
                            (elim x)
                            (elim y))
                 (<j> elim (p @ j))
                 (<j> elim (q @ j))
      = undefined

setTr0 (A : U) : set (tr0 A)
  = \(x y : tr0 A) (p q : Path (tr0 A) x y) -> <i j> squash{tr0 A} x y p q @ i @ j

PROP : U = (A : U) * prop A

propSigProp (A:U) (B:A -> U) (pA : prop A) (pB : (x:A) -> prop (B x)) : prop (Sigma A B) =
  \(x y : Sigma A B) ->
    <i> (pA x.1 y.1 @ i, lemPropF' A B pB x.1 y.1 (pA x.1 y.1) x.2 y.2 @ i)

propPath (A B : U) (pB : prop B) : prop (Path U A B) =
  retractProp (Path U A B) (equiv A B) (transEquiv' B A) (ua A B) (uaRetraction B A) rem
  where
  rem : prop (equiv A B) =
    propSigProp (A -> B) (isEquiv A B)
      (\(f g : A -> B) -> <i> \(x : A) -> pB (f x) (g x) @ i)
      (propIsEquivDirect' A B)

setPROP : set PROP =
  setSigProp U prop propIsProp (\(A B : PROP) -> propPath A.1 B.1 B.2)

opaque setPROP

codeTr0 (A : U) (x : A) : tr0 A -> PROP =
  recTr0 A PROP setPROP
    (\(y : A) -> (inh (Path A x y), propInh (Path A x y)))

encodeTr0Refl (A : U) (x : A) : (codeTr0 A x (inc x)).1 = inc (<_> x)

encodeTr0 (A : U) (x : A) : (y : tr0 A) (p : Path (tr0 A) (inc x) y) -> (codeTr0 A x y).1
  = J (tr0 A) (inc x)
      (\(y : tr0 A) (p : Path (tr0 A) (inc x) y) -> (codeTr0 A x y).1)
      (encodeTr0Refl A x)

encodeTr0Inc (A : U) (x y : A) : (p : Path (tr0 A) (inc x) (inc y)) -> inh (Path A x y)
  = encodeTr0 A x (inc y)

data tr1 (A : U)
  = inc (x : A)
  | squash
      (x y : tr1 A)
      (p q : Path (tr1 A) x y)
      (r s : Path (Path (tr1 A) x y) p q)
      <i j k>
      [ (i=0) -> r @ j @ k
      , (i=1) -> s @ j @ k
      , (j=0) -> p @ k
      , (j=1) -> q @ k
      , (k=0) -> x
      , (k=1) -> y
      ]

recTr1 (A B : U) (lev : groupoid B) (f : A -> B) : tr1 A -> B = split
  inc x -> f x
  squash x y p q r s @ i j k ->
    lev
      (rec x)
      (rec y)
      (<k> rec (p @ k))
      (<k> rec (q @ k))
      (<j k> rec (r @ j @ k))
      (<j k> rec (s @ j @ k))
      @ i @ j @ k
    where
    rec : tr1 A -> B = recTr1 A B lev f

elimTr1 (A : U) (B : tr1 A -> U)
  (lev : (x : tr1 A) -> groupoid (B x))
  (f : (x : A) -> B (inc x))
  : (x : tr1 A) -> B x = split
  inc x -> f x
  squash x y p q r s @ i j k -> TODO @ i @ j @ k
    where
    elim : (x : tr1 A) -> B x = elimTr1 A B lev f

    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> B (squash{tr1 A} x y p q r s @ i @ j @ k))
                                       (elim x)
                                       (elim y))
                            (<k> elim (p @ k))
                            (<k> elim (q @ k)))
                 (<j k> elim (r @ j @ k))
                 (<j k> elim (s @ j @ k))
      = undefined

groupoidTr1 (A : U) : groupoid (tr1 A)
  = \(x y : tr1 A) (p q : Path (tr1 A) x y) (r s : Path (Path (tr1 A) x y) p q) ->
     <i j k> squash{tr1 A} x y p q r s @ i @ j @ k

codeTr1 (A : U) (x : A) : tr1 A -> SET =
  recTr1 A SET groupoidSET
    (\(y : A) -> (tr0 (Path A x y), setTr0 (Path A x y)))

encodeTr1Refl (A : U) (x : A) : (codeTr1 A x (inc x)).1 = inc (<_> x)

encodeTr1 (A : U) (x : A) : (y : tr1 A) (p : Path (tr1 A) (inc x) y) -> (codeTr1 A x y).1
  = J (tr1 A) (inc x)
      (\(y : tr1 A) (p : Path (tr1 A) (inc x) y) -> (codeTr1 A x y).1)
      (encodeTr1Refl A x)

encodeTr1Inc (A : U) (x y : A) : (p : Path (tr1 A) (inc x) (inc y)) -> tr0 (Path A x y)
  = encodeTr1 A x (inc y)

decodeTr1Inc (A : U) (x y : A) : tr0 (Path A x y) -> Path (tr1 A) (inc x) (inc y)
  = recTr0 (Path A x y) (Path (tr1 A) (inc x) (inc y))
      (groupoidTr1 A (inc x) (inc y))
      (\(p : Path A x y) -> <i> inc (p @ i))

decodeTr1 (A : U) (x : A) : (y : tr1 A) -> (codeTr1 A x y).1 -> Path (tr1 A) (inc x) y
  = elimTr1 A (\(y : tr1 A) -> (codeTr1 A x y).1 -> Path (tr1 A) (inc x) y)
      TODO
      (decodeTr1Inc A x)
  where
  -- TODO hlevel
  TODO : (y : tr1 A) -> groupoid ((codeTr1 A x y).1 -> Path (tr1 A) (inc x) y)
    = undefined

decodeEncodeTr1 (A : U) (x : A)
  : (y : tr1 A) (p : Path (tr1 A) (inc x) y) ->
    Path (Path (tr1 A) (inc x) y)
         (decodeTr1 A x y (encodeTr1 A x y p))
         p
  = J (tr1 A) (inc x)
      (\(y : tr1 A) (p : Path (tr1 A) (inc x) y) ->
        Path (Path (tr1 A) (inc x) y)
             (decodeTr1 A x y (encodeTr1 A x y p))
             p)
      (<k i> inc (hcomp A (transGen (<_> A) k x)
                        [ (i=0) -> <l> transGen (<_> A) (l \/ k) x
                        , (i=1) -> <l> transGen (<_> A) (l \/ k) x
                        , (k=1) -> <l> x
                        ]))

data tr2 (A : U)
  = inc (x : A)
  | squash
      (x y : tr2 A)
      (p q : Path (tr2 A) x y)
      (r s : Path (Path (tr2 A) x y) p q)
      (t u : Path (Path (Path (tr2 A) x y) p q) r s)
      <i j k l>
      [ (i=0) -> t @ j @ k @ l
      , (i=1) -> u @ j @ k @ l
      , (j=0) -> r @ k @ l
      , (j=1) -> s @ k @ l
      , (k=0) -> p @ l
      , (k=1) -> q @ l
      , (l=0) -> x
      , (l=1) -> y
      ]

recTr2 (A B : U) (lev : twogroupoid B) (f : A -> B) : tr2 A -> B = split
  inc x -> f x
  squash x y p q r s t u @ i j k l ->
    lev
      (rec x)
      (rec y)
      (<l> rec (p @ l))
      (<l> rec (q @ l))
      (<k l> rec (r @ k @ l))
      (<k l> rec (s @ k @ l))
      (<j k l> rec (t @ j @ k @ l))
      (<j k l> rec (u @ j @ k @ l))
      @ i @ j @ k @ l
    where
    rec : tr2 A -> B = recTr2 A B lev f

elimTr2 (A : U) (B : tr2 A -> U)
  (lev : (x : tr2 A) -> twogroupoid (B x))
  (f : (x : A) -> B (inc x))
  : (x : tr2 A) -> B x = split
  inc x -> f x
  squash x y p q r s t u @ i j k l -> TODO @ i @ j @ k @ l
    where
    elim : (x : tr2 A) -> B x = elimTr2 A B lev f

    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> PathP (<l> B (squash{tr2 A} x y p q r s t u @ i @ j @ k @ l))
                                                  (elim x)
                                                  (elim y))
                                       (<l> elim (p @ l))
                                       (<l> elim (q @ l)))
                            (<k l> elim (r @ k @ l))
                            (<k l> elim (s @ k @ l)))
                 (<j k l> elim (t @ j @ k @ l))
                 (<j k l> elim (u @ j @ k @ l))
      = undefined

twogroupoidTr2 (A : U) : twogroupoid (tr2 A)
  = \(x y : tr2 A)
     (p q : Path (tr2 A) x y)
     (r s : Path (Path (tr2 A) x y) p q)
     (t u : Path (Path (Path (tr2 A) x y) p q) r s) ->
     <i j k l> squash{tr2 A} x y p q r s t u @ i @ j @ k @ l

mapTr2 (A B : U) (f : A -> B) : tr2 A -> tr2 B
  = recTr2 A (tr2 B) (twogroupoidTr2 B) (\(x : A) -> inc (f x))

codeTr2 (A : U) (x : A) : tr2 A -> GROUPOID =
  recTr2 A GROUPOID twogroupoidGROUPOID
    (\(y : A) -> (tr1 (Path A x y), groupoidTr1 (Path A x y)))

encodeTr2Refl (A : U) (x : A) : (codeTr2 A x (inc x)).1 = inc (<_> x)

encodeTr2 (A : U) (x : A) : (y : tr2 A) (p : Path (tr2 A) (inc x) y) -> (codeTr2 A x y).1
  = J (tr2 A) (inc x)
      (\(y : tr2 A) (p : Path (tr2 A) (inc x) y) -> (codeTr2 A x y).1)
      (encodeTr2Refl A x)

encodeTr2Inc (A : U) (x y : A) : (p : Path (tr2 A) (inc x) (inc y)) -> tr1 (Path A x y)
  = encodeTr2 A x (inc y)

decodeTr2Inc (A : U) (x y : A) : tr1 (Path A x y) -> Path (tr2 A) (inc x) (inc y)
  = recTr1 (Path A x y) (Path (tr2 A) (inc x) (inc y))
      (twogroupoidTr2 A (inc x) (inc y))
      (\(p : Path A x y) -> <i> inc (p @ i))

decodeTr2 (A : U) (x : A) : (y : tr2 A) -> (codeTr2 A x y).1 -> Path (tr2 A) (inc x) y
  = elimTr2 A (\(y : tr2 A) -> (codeTr2 A x y).1 -> Path (tr2 A) (inc x) y)
      TODO
      (decodeTr2Inc A x)
  where
  -- TODO hlevel
  TODO : (y : tr2 A) -> twogroupoid ((codeTr2 A x y).1 -> Path (tr2 A) (inc x) y)
    = undefined

decodeEncodeTr2 (A : U) (x : A)
  : (y : tr2 A) (p : Path (tr2 A) (inc x) y) ->
    Path (Path (tr2 A) (inc x) y)
         (decodeTr2 A x y (encodeTr2 A x y p))
         p
  = J (tr2 A) (inc x)
      (\(y : tr2 A) (p : Path (tr2 A) (inc x) y) ->
        Path (Path (tr2 A) (inc x) y)
             (decodeTr2 A x y (encodeTr2 A x y p))
             p)
      (<k i> inc (hcomp A (transGen (<_> A) k x)
                        [ (i=0) -> <l> transGen (<_> A) (l \/ k) x
                        , (i=1) -> <l> transGen (<_> A) (l \/ k) x
                        , (k=1) -> <l> x
                        ]))

data tr3 (A : U)
  = inc (x : A)
  | squash
      (x y : tr3 A)
      (p q : Path (tr3 A) x y)
      (r s : Path (Path (tr3 A) x y) p q)
      (t u : Path (Path (Path (tr3 A) x y) p q) r s)
      (v w : Path (Path (Path (Path (tr3 A) x y) p q) r s) t u)
      <i j k l m>
      [ (i=0) -> v @ j @ k @ l @ m
      , (i=1) -> w @ j @ k @ l @ m
      , (j=0) -> t @ k @ l @ m
      , (j=1) -> u @ k @ l @ m
      , (k=0) -> r @ l @ m
      , (k=1) -> s @ l @ m
      , (l=0) -> p @ m
      , (l=1) -> q @ m
      , (m=0) -> x
      , (m=1) -> y
      ]

recTr3 (A B : U) (lev : threegroupoid B) (f : A -> B) : tr3 A -> B = split
  inc x -> f x
  squash x y p q r s t u v w @ i j k l m ->
    lev
      (rec x)
      (rec y)
      (<m> rec (p @ m))
      (<m> rec (q @ m))
      (<l m> rec (r @ l @ m))
      (<l m> rec (s @ l @ m))
      (<k l m> rec (t @ k @ l @ m))
      (<k l m> rec (u @ k @ l @ m))
      (<j k l m> rec (v @ j @ k @ l @ m))
      (<j k l m> rec (w @ j @ k @ l @ m))
      @ i @ j @ k @ l @ m
    where
    rec : tr3 A -> B = recTr3 A B lev f

elimTr3 (A : U) (B : tr3 A -> U)
  (lev : (x : tr3 A) -> threegroupoid (B x))
  (f : (x : A) -> B (inc x))
  : (x : tr3 A) -> B x = split
  inc x -> f x
  squash x y p q r s t u v w @ i j k l m -> TODO @ i @ j @ k @ l @ m
    where
    elim : (x : tr3 A) -> B x = elimTr3 A B lev f

    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> PathP (<l> PathP (<m> B (squash{tr3 A} x y p q r s t u v w @ i @ j @ k @ l @ m))
                                                             (elim x)
                                                             (elim y))
                                                  (<m> elim (p @ m))
                                                  (<m> elim (q @ m)))
                                       (<l m> elim (r @ l @ m))
                                       (<l m> elim (s @ l @ m)))
                            (<k l m> elim (t @ k @ l @ m))
                            (<k l m> elim (u @ k @ l @ m)))
                 (<j k l m> elim (v @ j @ k @ l @ m))
                 (<j k l m> elim (w @ j @ k @ l @ m))
      = undefined



-- Section: "Constant" squares

-- This type is like the "general constant squares" in constcubes.ctt
Csq (A : U) (x y z : A) (p : Path A x y) (q : Path A y z) : U
  = PathP (<i> Path A (p @ i) (q @ i)) p q

-- This is an old cubicaltt thing, "constSquare"
csq (A : U) (x y z : A) (p : Path A x y) (q : Path A y z)
  (r : Path (Path A y y) (<_> y) (<_> y))
  : PathP (<i> Path A (p @ i) (q @ i)) p q
  = <i j> hcomp A (r @ i @ j)
            [ (i=0) -> <k> p @ j \/ -k
            , (i=1) -> <k> q @ j /\ k
            , (j=0) -> <k> p @ i \/ -k
            , (j=1) -> <k> q @ i /\ k
            ]

-- Negating k gives us the inverse map
csqInv (A : U) (x y z : A) (p : Path A x y) (q : Path A y z)
  (r : PathP (<i> Path A (p @ i) (q @ i)) p q)
  : Path (Path A y y) (<_> y) (<_> y)
  = <i j> hcomp A (r @ i @ j)
            [ (i=0) -> <k> p @ j \/ k
            , (i=1) -> <k> q @ j /\ -k
            , (j=0) -> <k> p @ i \/ k
            , (j=1) -> <k> q @ i /\ -k
            ]

-- These maps are propositionally equal to transport over this path in
-- the universe, used to define ccube below
csqPath (A : U) (x y z : A) (p : Path A x y) (q : Path A y z)
  : Path U (Path (Path A y y) (<_> y) (<_> y))
           (PathP (<i> Path A (p @ i) (q @ i)) p q)
  = <k> PathP (<i> Path A (p @ i \/ -k) (q @ i /\ k)) (<j> p @ j \/ -k) (<j> q @ j /\ k)

csqFill (A : U) (x y z : A) (p : Path A x y) (q : Path A y z)
  (r : Path (Path A y y) (<_> y) (<_> y))
  : PathP (<f> csqPath A x y z p q @ f) r (csq A x y z p q r)
  = <f i j> hfill A (r @ i @ j)
              [ (i=0) -> <k> p @ j \/ -k
              , (i=1) -> <k> q @ j /\ k
              , (j=0) -> <k> p @ i \/ -k
              , (j=1) -> <k> q @ i /\ k
              ]
              @ f

csqInvFill (A : U) (x y z : A) (p : Path A x y) (q : Path A y z)
  (r : PathP (<i> Path A (p @ i) (q @ i)) p q)
  : PathP (<f> csqPath A x y z p q @ -f) r (csqInv A x y z p q r)
  = <f i j> hfill A (r @ i @ j)
              [ (i=0) -> <k> p @ j \/ k
              , (i=1) -> <k> q @ j /\ -k
              , (j=0) -> <k> p @ i \/ k
              , (j=1) -> <k> q @ i /\ -k
              ]
              @ f

csqRightInv (A : U) (x y z : A) (p : Path A x y) (q : Path A y z)
  (r : Csq A x y z p q)
  : Path (Csq A x y z p q)
         (csq A x y z p q (csqInv A x y z p q r))
         r
  = step3
  where
  step1 : PathP (<k> csqPath A x y z p q @ k)
                (csqInv A x y z p q r)
                (csq A x y z p q (csqInv A x y z p q r))
    = csqFill A x y z p q (csqInv A x y z p q r)

  step2 : PathP (<k> csqPath A x y z p q @ k)
                (csqInv A x y z p q r)
                r
    = <k> csqInvFill A x y z p q r @ -k

  step3 : Path (Csq A x y z p q)
               (csq A x y z p q (csqInv A x y z p q r))
               r
    = <i> comp (<k> csqPath A x y z p q @ k)
               (csqInv A x y z p q r)
               [ (i=0) -> <k> step1 @ k
               , (i=1) -> <k> step2 @ k
               ]

-- A "constant cube" with all sides the same 2-loop. We will need this
-- for mapping J3S1 -> S2 to get pi3S2 ~= pi2S2
ccube (A : U) (x : A) (p : Path (Path A x x) (<_> x) (<_> x))
  : PathP (<i> PathP (<j> PathP (<k> A) (p @ i @ j)
                                        (p @ i @ j))
                     (<k> p @ i @ k)
                     (<k> p @ i @ k))
          (<j k> p @ j @ k)
          (<j k> p @ j @ k)
  = <i> transGen (<t> csqPath A x x x (p @ i) (p @ i) @ t) (i \/ -i) p

-- We will also need the following "homogeneous" square things:

hsq (A : U) (x y : A) (p : Path A x y)
  (r : Path (Path A x x) (<_> x) (<_> x))
  : Path (Path A x y) p p
  = <i j> hcomp A
            (r @ i @ j)
            [ (i=0) -> <k> p @ j /\ k
            , (i=1) -> <k> p @ j /\ k
            , (j=0) -> <k> x
            , (j=1) -> <k> p @ k
            ]

hsqInv (A : U) (x y : A) (p : Path A x y)
  (r : Path (Path A x y) p p)
  : Path (Path A x x) (<_> x) (<_> x)
  = <i j> hcomp A
            (r @ i @ j)
            [ (i=0) -> <k> p @ j /\ -k
            , (i=1) -> <k> p @ j /\ -k
            , (j=0) -> <k> x
            , (j=1) -> <k> p @ -k
            ]

hsqPath (A : U) (x y : A) (p : Path A x y)
  : Path U (Path (Path A x x) (<_> x) (<_> x))
           (Path (Path A x y) p p)
  = <k> PathP (<i> Path A x (p @ k)) (<j> p @ j /\ k) (<j> p @ j /\ k)

hsqFill (A : U) (x y : A) (p : Path A x y)
  (r : Path (Path A x x) (<_> x) (<_> x))
  : PathP (<f> hsqPath A x y p @ f) r (hsq A x y p r)
  = <f i j> hfill A (r @ i @ j)
              [ (i=0) -> <k> p @ j /\ k
              , (i=1) -> <k> p @ j /\ k
              , (j=0) -> <k> x
              , (j=1) -> <k> p @ k
              ]
              @ f

hsqInvFill (A : U) (x y : A) (p : Path A x y)
  (r : Path (Path A x y) p p)
  : PathP (<f> hsqPath A x y p @ -f) r (hsqInv A x y p r)
  = <f i j> hfill A (r @ i @ j)
              [ (i=0) -> <k> p @ j /\ -k
              , (i=1) -> <k> p @ j /\ -k
              , (j=0) -> <k> x
              , (j=1) -> <k> p @ -k
              ]
              @ f

hsqRightInv (A : U) (x y : A) (p : Path A x y)
  (r : Path (Path A x y) p p)
  : Path (Path (Path A x y) p p)
         (hsq A x y p (hsqInv A x y p r))
         r
  = step3
  where
  step1 : PathP (<k> hsqPath A x y p @ k)
                (hsqInv A x y p r)
                (hsq A x y p (hsqInv A x y p r))
    = hsqFill A x y p (hsqInv A x y p r)

  step2 : PathP (<k> hsqPath A x y p @ k)
                (hsqInv A x y p r)
                r
    = <k> hsqInvFill A x y p r @ -k

  step3 : Path (Path (Path A x y) p p)
               (hsq A x y p (hsqInv A x y p r))
               r
    = <i> comp (<k> hsqPath A x y p @ k)
               (hsqInv A x y p r)
               [ (i=0) -> <k> step1 @ k
               , (i=1) -> <k> step2 @ k
               ]

hsqExt (A : U) (x y : A) (p : Path A x y)
  (r s : Path (Path A x y) p p)
  (t : Path (Path (Path A x x) (<_> x) (<_> x))
            (hsqInv A x y p r)
            (hsqInv A x y p s))
  : Path (Path (Path A x y) p p) r s
  = <i> hcomp (Path (Path A x y) p p)
          (hsq A x y p (t @ i))
          [ (i=0) -> <i> hsqRightInv A x y p r @ i
          , (i=1) -> <i> hsqRightInv A x y p s @ i
          ]

opaque hsqExt



-- Section: Local-global looping

-- We will need "local-global looping" (Kraus and Sattler), aka "the
-- key maneuver" (Licata and Brunerie), an equivalence between these
-- two types:

Local (A : U) : U = (x : A) -> Path A x x
Global (A : U) : U = Path (Path U A A) (<_> A) (<_> A) -- i.e. Ω^2(U, A)

-- helper for going to the flipped version of Local
localId (A : U) (h : (x : A) -> Path A x x) : Path (A -> A) (idfun A) (idfun A)
  = <i> \(x : A) -> h x @ i

localIdIsEquiv (A : U) (h : (x : A) -> Path A x x) : PathP (<i> isEquiv A A (localId A h @ i)) (idIsEquiv A) (idIsEquiv A) =
  lemPropF' (A -> A) (isEquiv A A)
    (propIsEquivDirect' A A)
    (idfun A) (idfun A) (localId A h)
    (idIsEquiv A) (idIsEquiv A)

-- with Glue we get the "local to global" map:
global (A : U) (h : (x : A) -> Path A x x) : Path (Path U A A) (<_> A) (<_> A) =
  <i j> Glue A [ (i=0) -> (A, idEquiv A)
               , (i=1) -> (A, idEquiv A)
               , (j=0) -> (A, localId A h @ i, localIdIsEquiv A h @ i)
               , (j=1) -> (A, idEquiv A)
               ]

-- transGen gives a nice "global to local" map
local (A : U) (H : Global A) (x : A) : Path A x x =
  <i> transGen (<j> H @ i @ j) (i \/ -i) x

-- flipped version
local' (A : U) (H : Global A) : Path (A -> A) (idfun A) (idfun A) =
  localId A (local A H)

local'IsEquiv (A : U) (H : Global A) : PathP (<i> isEquiv A A (local' A H @ i)) (idIsEquiv A) (idIsEquiv A) =
  localIdIsEquiv A (local A H)

local'Equiv (A : U) (H : Global A) : Path (equiv A A) (idEquiv A) (idEquiv A) =
  <i> (local' A H @ i, local'IsEquiv A H @ i)

localThingy (A : U) (H : Global A) : PathP (<i> PathP (<j> H @ i @ j -> A) (local' A H @ i) (idfun A)) (<_> idfun A) (<_> idfun A) =
  <i j> \(h : H @ i @ j) -> transGen (<l> H @ i @ l \/ j) (-i \/ i \/ j) h

-- TODO by hlevel
TODO_localThingyIsEquiv (A : U) (H : Global A) : PathP (<i> PathP (<j> isEquiv (H @ i @ j) A (localThingy A H @ i @ j)) (local'IsEquiv A H @ i) (idIsEquiv A)) (<_> idIsEquiv A) (<_> idIsEquiv A)
  = undefined

localThingyEquiv (A : U) (H : Global A) : PathP (<i> PathP (<j> equiv (H @ i @ j) A) (local'Equiv A H @ i) (idEquiv A)) (<_> idEquiv A) (<_> idEquiv A) =
  <i j> (localThingy A H @ i @ j, TODO_localThingyIsEquiv A H @ i @ j)

-- TODO by hlevel
TODO_globalEqIsEquiv (A : U) (H0 H1 : Global A) (eq : Path (Path (A -> A) (idfun A) (idfun A)) (local' A H0) (local' A H1))
  : PathP (<i> PathP (<j> isEquiv A A (eq @ i @ j)) (idIsEquiv A) (idIsEquiv A)) (local'IsEquiv A H0) (local'IsEquiv A H1)
  = undefined

globalEqEquiv (A : U) (H0 H1 : Global A) (eq : Path (Path (A -> A) (idfun A) (idfun A)) (local' A H0) (local' A H1))
  : Path (Path (equiv A A) (idEquiv A) (idEquiv A)) (local'Equiv A H0) (local'Equiv A H1)
  = <i j> (eq @ i @ j, TODO_globalEqIsEquiv A H0 H1 eq @ i @ j)

-- extensionality principle for Global A
globalEq (A : U) (H0 H1 : Global A) (eq : Path (Path (A -> A) (idfun A) (idfun A)) (local' A H0) (local' A H1))
  : Path (Global A) H0 H1
  = <k i j> Glue A [ (i=0) -> (A, idEquiv A)
                   , (i=1) -> (A, idEquiv A)
                   , (j=0) -> (A, globalEqEquiv A H0 H1 eq @ k @ i)
                   , (j=1) -> (A, idEquiv A)
                   , (k=0) -> (H0 @ i @ j, localThingyEquiv A H0 @ i @ j)
                   , (k=1) -> (H1 @ i @ j, localThingyEquiv A H1 @ i @ j)
                   ]


localLemma (A : U) (H : Global A)
  (x : A) (p : Path A x x)
  (t : PathP (<i> PathP (<j> H @ i @ j) x (p @ i)) (<_> x) (<_> x))
  : PathP (<i> Path A (local A H x @ i) (p @ i)) (<_> x) (<_> x)
  = <i j> transGen (<k> H @ i @ j \/ k) (-i \/ i \/ j) (t @ i @ j)

globalLemma (A : U) (h : Local A)
  (x : A) (p : Path A x x)
  (t : PathP (<i> Path A (h x @ i) (p @ i)) (<_> x) (<_> x))
  : PathP (<i> PathP (<j> global A h @ i @ j) x (p @ i)) (<_> x) (<_> x)
  = <i j> glue (t @ i @ j)
               [ (i=0) -> x
               , (i=1) -> x
               , (j=0) -> x
               , (j=1) -> p @ i
               ]

localGlobal (A : U) (h : Local A) : Path (Local A) (local A (global A h)) h
  = <i> \(x : A) -> <j> localLemma A (global A h) x (h x)
                          (globalLemma A h x (h x) (<i _> h x @ i))
                          @ j @ i

globalLocal (A : U) (H : Global A) : Path (Global A) (global A (local A H)) H
  = globalEq A (global A (local A H)) H
      (<i j> \(x : A) -> localGlobal A (local A H) @ i x @ j)

-- extensionality principle for Ω(Global A, H)
loopGlobalEq (A : U) (H : Global A)
  (p q : Path (Global A) H H)
  (eq : (x : A) -> Path (Path (Path A x x) (local A H x) (local A H x))
                        (<i> local A (p @ i) x)
                        (<i> local A (q @ i) x))
  : Path (Path (Global A) H H) p q
  = <i j> hcomp (Global A)
                (global A (eq' @ i @ j))
                [ (i=0) -> <k> globalLocal A (p @ j) @ k
                , (i=1) -> <k> globalLocal A (q @ j) @ k
                , (j=0) -> <k> globalLocal A H @ k
                , (j=1) -> <k> globalLocal A H @ k
                ]
  where
  eq' : Path (Path ((x : A) -> Path A x x) (local A H) (local A H))
             (<i> local A (p @ i))
             (<i> local A (q @ i))
    = <i j> \(x : A) -> <k> eq x @ i @ j @ k



-- Section: S1
--
-- This is mostly copied from loops1.ctt, by Mörtberg

data S1
  = base
  | loop1 <i>
      [ (i=0) -> base
      , (i=1) -> base
      ]

loopS1 : U = Path S1 base base
loop : loopS1 = <i> loop1{S1} @ i
invLoop : loopS1 = <i> loop @ -i
compS1 : loopS1 -> loopS1 -> loopS1 = compPath S1 base base base

helix : S1 -> U = split
  base -> Z
  loop1 @ i -> sucPathZ @ i

encode (x : S1) (p : Path S1 base x) : helix x =
  subst S1 helix base x p zeroZ

loopPos : nat -> loopS1 = split
  zero -> <_> base
  suc n -> compS1 (loopPos n) loop

loopNeg : nat -> loopS1 = split
  zero -> invLoop
  suc n -> compS1 (loopNeg n) invLoop

loopIt : (n : Z) -> loopS1 = split
  pos n -> loopPos n
  neg n -> loopNeg n

decodeSquarePos : (n : nat) -> Square S1 base base base base
                                      (<_> base)
                                      loop
                                      (loopIt (predZ (pos n)))
                                      (loopIt (pos n)) = split
  zero -> <i j> loop @ i \/ -j
  suc n -> <i j> hfill S1 (loopPos n @ j) [ (j = 0) -> <_> base
                                          , (j = 1) -> loop ] @ i

decodeSquareNeg (n : nat) : Square S1 base base base base
                                   (<_> base)
                                   loop
                                   (loopIt (predZ (neg n)))
                                   (loopIt (neg n)) =
  <i j> hcomp S1 (loopNeg n @ j)
                 [ (i=1) -> <_> loopNeg n @ j
                 , (j=0) -> <_> base
                 , (j=1) -> <k> loop @ i \/ -k ]

decodeSquare : (n : Z) -> Square S1 base base base base
                                 (<_> base)
                                 loop
                                 (loopIt (predZ n))
                                 (loopIt n) = split
  pos n -> decodeSquarePos n
  neg n -> decodeSquareNeg n

decode : (x : S1) -> helix x -> Path S1 base x = split
  base -> loopIt
  loop1 @ i -> \(y : sucPathZ @ i) -> <j>
    let n : Z = unglue y Z [(i=0) -> (Z,(sucZ,equivSucZ))
                           ,(i=1) -> (Z,idEquiv Z)]
    in hcomp S1 (decodeSquare n @ i @ j)
                [ (j=0) -> <_> base
                , (j=1) -> <_> loop @ i
                , (i=0) -> <k> loopIt (predsucZ y @ k) @ j
                , (i=1) -> <_> loopIt y @ j ]


decodeEncode (x : S1) (p : Path S1 base x) : Path (Path S1 base x) (decode x (encode x p)) p =
  transGen (<i> Path (Path S1 base (p @ i))
                     (decode (p @ i) (encode (p @ i) (<j> p @ i /\ j)))
                     (<j> p @ i /\ j))
            0
            (<_ _> base)

-- what I need:

rotLoop : (a : S1) -> Path S1 a a = split
  base -> loop
  loop1 @ i -> csq S1 base base base loop loop (<_ _> base) @ i

winding (p : loopS1) : Z
  = encode base p

-- "extensionality" for loopS1 in terms of winding numbers
loopS1Ext (p q : loopS1)
  (h : Path Z (winding p) (winding q))
  : Path loopS1 p q
  = <i> hcomp loopS1
          (decode base (h @ i))
          [ (i=0) -> decodeEncode base p
          , (i=1) -> decodeEncode base q
          ]

setLoop (p q : loopS1) (r s : Path loopS1 p q) : Path (Path loopS1 p q) r s =
  let f : loopS1 -> Z = encode base
      g : Z -> loopS1 = decode base
  in <j i> hcomp loopS1 (g (ZSet (f p) (f q) (<i> f (r @ i)) (<i> f (s @ i)) @ j @ i))
                        [ (i = 0) -> decodeEncode base p
                        , (i = 1) -> decodeEncode base q
                        , (j = 0) -> decodeEncode base (r @ i)
                        , (j = 1) -> decodeEncode base (s @ i) ]

groupoidS1basebase : set (Path S1 base base) = setLoop

groupoidS1base : (y : S1) -> set (Path S1 base y) = split
  base -> groupoidS1basebase
  loop1 @ i ->
    lemPropF' S1
      (\(y : S1) -> set (Path S1 base y))
      (\(y : S1) (f g : set (Path S1 base y)) ->
        <i> setIsProp (Path S1 base y) f g @ i)
      base base (<i> loop1{S1} @ i)
      groupoidS1basebase groupoidS1basebase
      @ i

groupoidS1 : groupoid S1 = split
  base -> groupoidS1base
  loop1 @ i ->
    lemPropF' S1
      (\(x : S1) -> (y : S1) -> set (Path S1 x y))
      (\(x : S1) (f g : (y : S1) -> set (Path S1 x y)) ->
        <i> \(y : S1) -> setIsProp (Path S1 x y) (f y) (g y) @ i)
      base base (<i> loop1{S1} @ i)
      groupoidS1base groupoidS1base @ i



-- Section: S2
--
-- I need a similar thing for S2, giving "wrapping numbers" for pi2S2
-- with an extensionality principle.
--
-- This is standard, but... what the hell, let's James it up!

data S2
  = base
  | loop2 <i j>
      [ (i=0) -> base
      , (i=1) -> base
      , (j=0) -> base
      , (j=1) -> base
      ]

-- James construction for ΩS2
data JS1
  = base
  | loops (x : JS1) <i>
      [ (i=0) -> x
      , (i=1) -> x
      ]

loopsJS1 (x : JS1) : Path JS1 x x =
  <i> loops{JS1} x @ i

loopS2 : S2 -> U = split
  base -> JS1
  loop2 @ i j -> global JS1 loopsJS1 @ i @ j

loopsLoopS2 (p : Path S2 base base) : Path (Path S2 base base) p p =
  local (Path S2 base base) (<i j> Path S2 base (loop2{S2} @ i @ j)) p

encodeJS1 (x : S2) (p : Path S2 base x) : loopS2 x =
  transGen (<i> loopS2 (p @ i)) 0 base

toJS1 : Path S2 base base -> JS1 = encodeJS1 base

unJS1 : JS1 -> Path S2 base base = split
  base -> <_> base
  loops x @ i -> loopsLoopS2 (unJS1 x) @ i

decodeJS1 : (x : S2) (l : loopS2 x) -> Path S2 base x = split
  base -> unJS1
  loop2 @ i j -> rem @ i @ j
    where
    have : PathP (<i> PathP (<j> loopS2 (loop2{S2} @ i @ j) -> Path S2 base base) (\(x : JS1) -> loopsLoopS2 (unJS1 x) @ i) unJS1) (<_> unJS1) (<_> unJS1)
      = <i j> \(p : loopS2 (loop2{S2} @ i @ j)) ->
        unJS1 (unglue p JS1 [ (i=0) -> (JS1, idEquiv JS1)
                            , (i=1) -> (JS1, idEquiv JS1)
                            , (j=0) -> (JS1, localId JS1 loopsJS1 @ i, localIdIsEquiv JS1 loopsJS1 @ i)
                            , (j=1) -> (JS1, idEquiv JS1)
                            ])

    -- hmm
    rem : PathP (<i> PathP (<j> loopS2 (loop2{S2} @ i @ j) -> Path S2 base (loop2{S2} @ i @ j)) unJS1 unJS1) (<_> unJS1) (<_> unJS1)
      = <i j> \(p : loopS2 (loop2{S2} @ i @ j)) ->
                hcomp (Path S2 base (loop2{S2} @ i @ j))
                      (transGen (<l> Path S2 base (loop2{S2} @ i @ -l \/ j)) (-i \/ i \/ j) (have @ i @ j p))
                      [ (i=0) -> <_> unJS1 p
                      , (i=1) -> <_> unJS1 p
                      , (j=0) -> <k> transGen (<l> Path S2 base (loop2{S2} @ i @ -l /\ -k)) (-i \/ i \/ k)
                                       (transGen (<l> Path S2 base (loop2{S2} @ i @ l /\ -k)) (-i \/ i \/ k)
                                         (unJS1 p))
                      , (j=1) -> <_> unJS1 p
                      ]

decodeEncodeJS1 : (x : S2) (p : Path S2 base x) -> Path (Path S2 base x) (decodeJS1 x (encodeJS1 x p)) p
  = J S2 base
      (\(x : S2) (p : Path S2 base x) -> Path (Path S2 base x) (decodeJS1 x (encodeJS1 x p)) p)
      (<_ _> base)

decodeEncodeJS1Base : (p : Path S2 base base) -> Path (Path S2 base base) (unJS1 (toJS1 p)) p
  = decodeEncodeJS1 base

-- now we've got extensionality for Ω2S2 in terms of ΩJS1:
loopS2ExtJS1 (p q : Path (Path S2 base base) (<_> base) (<_> base))
  (h : Path (Path JS1 base base) (<i> toJS1 (p @ i)) (<i> toJS1 (q @ i)))
  : Path (Path (Path S2 base base) (<_> base) (<_> base)) p q
  = <i j k> hcomp S2
                  (unJS1 (h @ i @ j) @ k)
                  [ (i=0) -> <l> decodeEncodeJS1Base (p @ j) @ l @ k
                  , (i=1) -> <l> decodeEncodeJS1Base (q @ j) @ l @ k
                  , (j=0) -> <l> decodeEncodeJS1Base (<_> base) @ l @ k
                  , (j=1) -> <l> decodeEncodeJS1Base (<_> base) @ l @ k
                  , (k=0) -> <l> base
                  , (k=1) -> <l> base
                  ]

-- now we need extensionality for ΩJS1 in terms of ΩS1. S1 is
-- equivalent to the 1-truncation of JS1
truncJS1 : JS1 -> S1 = split
  base -> base
  loops x @ i -> rotLoop (truncJS1 x) @ i

incJS1 : S1 -> JS1 = split
  base -> base
  loop1 @ i -> loops{JS1} base @ i

truncIncJS1 : (x : S1) -> Path S1 (truncJS1 (incJS1 x)) x = split
  base -> <_> base
  loop1 @ i -> <_> loop1{S1} @ i

incRotLoop : (x : S1) -> Path (Path (tr1 JS1) (inc (incJS1 x)) (inc (incJS1 x)))
                              (<i> inc (incJS1 (rotLoop x @ i)))
                              (<i> inc (loops{JS1} (incJS1 x) @ i))
  = split
  base -> <_ i> inc (loops{JS1} base @ i)
  loop1 @ i -> TODO @ i
    where
    -- TODO by hlevel
    TODO : PathP (<i> Path (Path (tr1 JS1) (inc (loops{JS1} base @ i)) (inc (loops{JS1} base @ i)))
                           (<j> inc (incJS1 (rotLoop (loop1{S1} @ i) @ j)))
                           (<j> inc (loops{JS1} (incJS1 (loop1{S1} @ i)) @ j)))
                 (<_ j> inc (loops{JS1} base @ j))
                 (<_ j> inc (loops{JS1} base @ j))
      = undefined

incTruncJS1 : (x : JS1) -> Path (tr1 JS1) (inc (incJS1 (truncJS1 x))) (inc x) = split
  base -> <_> inc base
  loops x @ i -> rem x (incTruncJS1 x) @ i
    where
    truncJS1Loops : (x : tr1 JS1) -> Path (tr1 JS1) x x
      = elimTr1 JS1 (\(x : tr1 JS1) -> Path (tr1 JS1) x x)
          (\(x : tr1 JS1) -> setGroupoid (Path (tr1 JS1) x x) (groupoidTr1 JS1 x x))
          (\(x : JS1) -> <i> inc (loops{JS1} x @ i))

    lem : (x : S1) -> Path (Path (tr1 JS1) (inc (incJS1 x)) (inc (incJS1 x)))
                           (<k> inc (incJS1 (rotLoop x @ k)))
                           (<k> inc (loops{JS1} (incJS1 x) @ k))
      = split
      base -> <_ k> inc (loops{JS1} base @ k)
      loop1 @ i -> TODO @ i
        where
        -- TODO by hlevel
        TODO : PathP (<i> Path (Path (tr1 JS1)
                                     (inc (incJS1 (loop1{S1} @ i)))
                                     (inc (incJS1 (loop1{S1} @ i))))
                               (<k> inc (incJS1 (rotLoop (loop1{S1} @ i) @ k)))
                               (<k> inc (loops{JS1} (incJS1 (loop1{S1} @ i)) @ k)))
                     (<_ k> inc (loops{JS1} base @ k))
                     (<_ k> inc (loops{JS1} base @ k))
          = undefined

    rem (x : JS1) (y : Path (tr1 JS1) (inc (incJS1 (truncJS1 x))) (inc x))
      : PathP (<i> Path (tr1 JS1)
                        (inc (incJS1 (rotLoop (truncJS1 x) @ i)))
                        (inc (loops{JS1} x @ i))) y y
      = <i j> hcomp (tr1 JS1)
                    (lem (truncJS1 x) @ j @ i)
                    [ (i=0) -> <k> y @ j /\ k
                    , (i=1) -> <k> y @ j /\ k
                    , (j=0) -> <_> inc (incJS1 (rotLoop (truncJS1 x) @ i))
                    , (j=1) -> <k> truncJS1Loops (y @ k) @ i
                    ]

-- from Cubical.Foundations.GroupoidLaws
lUnit (A : U) (x y : A) (p : Path A x y)
  : Path (Path A x y) p (<i> hcomp A x [(i=0) -> <j> x, (i=1) -> <j> p @ j])
  = <k i> hcomp A
                (p @ -k /\ i)
                [ (i=0) -> <_> x
                , (i=1) -> <j> p @ -k \/ j
                , (k=0) -> <_> p @ i
                ]

-- what we really need is that two loops in JS1 are merely equal if
-- the induced paths in S1 are equal:
loopJS1Ext (p q : Path JS1 base base)
  (h : Path (Path S1 base base) (<i> truncJS1 (p @ i)) (<i> truncJS1 (q @ i)))
  : inh (Path (Path JS1 base base) p q)
  = step4
  where
  step1 : Path (Path (tr1 JS1) (inc base) (inc base))
               (<i> inc (incJS1 (truncJS1 (p @ i))))
               (<i> inc (incJS1 (truncJS1 (q @ i))))
    = <k i> inc (incJS1 (h @ k @ i))

  step2 : Path (Path (tr1 JS1) (inc base) (inc base))
               (<i> inc (p @ i))
               (<i> inc (q @ i))
    = <k> hcomp (Path (tr1 JS1) (inc base) (inc base))
                (step1 @ k)
                [ (k=0) -> <k i> incTruncJS1 (p @ i) @ k
                , (k=1) -> <k i> incTruncJS1 (q @ i) @ k
                ]

  step3 : Path (tr0 (Path JS1 base base)) (inc p) (inc q)
    = <i> hcomp (tr0 (Path JS1 base base))
                (encodeTr1Inc JS1 base base (step2 @ i))
                [ (i=0) -> <i> inc (<j> lUnit JS1 base base p @ -i @ j)
                , (i=1) -> <i> inc (<j> lUnit JS1 base base q @ -i @ j)
                ]

  step4 : inh (Path (Path JS1 base base) p q)
    = encodeTr0Inc (Path JS1 base base) p q step3

-- now we can define "wrapping" numbers for pi2S2 by going
-- pi2S2 -> pi1JS1 -> pi1S1 -> Z
wrapping (p : Path (Path S2 base base) (<_> base) (<_> base)) : Z
  = winding (<i> truncJS1 (toJS1 (p @ i)))

-- Composing the previous extensionality lemmas, we get mere equality
-- of 2-loops in S2 from equality of wrapping numbers.
wrappingExt (p q : Path (Path S2 base base) (<_> base) (<_> base))
  (h : Path Z (wrapping p) (wrapping q))
  : inh (Path (Path (Path S2 base base) (<_> base) (<_> base)) p q)
  = step3
  where
  step1 : Path (Path S1 base base)
               (<i> truncJS1 (toJS1 (p @ i)))
               (<i> truncJS1 (toJS1 (q @ i)))
    = loopS1Ext
        (<i> truncJS1 (toJS1 (p @ i)))
        (<i> truncJS1 (toJS1 (q @ i)))
        h

  step2 : inh (Path (Path JS1 base base) (<i> toJS1 (p @ i)) (<i> toJS1 (q @ i)))
    = loopJS1Ext
        (<i> toJS1 (p @ i))
        (<i> toJS1 (q @ i))
        step1

  step3 : inh (Path (Path (Path S2 base base) (<_> base) (<_> base)) p q)
    = mapInh
        (Path (Path JS1 base base) (<i> toJS1 (p @ i)) (<i> toJS1 (q @ i)))
        (Path (Path (Path S2 base base) (<_> base) (<_> base)) p q)
        (loopS2ExtJS1 p q)
        step2

-- later we will need this on tr2 S2

wrappingTr2 (p : Path (Path (tr2 S2) (inc base) (inc base)) (<_> inc base) (<_> inc base)) : Z
  = hmm2
  where
  hmm0 : Path (tr1 (Path S2 base base)) (inc (<_> base)) (inc (<_> base))
    = <i> hcomp (tr1 (Path S2 base base))
            (encodeTr2Inc S2 base base (p @ i))
            [ (i=0) -> <i> inc (<j> hfill S2 base [(j=0) -> <_> base, (j=1) -> <_> base] @ -i)
            , (i=1) -> <i> inc (<j> hfill S2 base [(j=0) -> <_> base, (j=1) -> <_> base] @ -i)
            ]

  hmm1 : tr0 (Path (Path S2 base base) (<_> base) (<_> base))
    = encodeTr1Inc
        (Path S2 base base)
        (<_> base) (<_> base)
        hmm0

  hmm2 : Z
    = recTr0
        (Path (Path S2 base base) (<_> base) (<_> base))
        Z
        ZSet
        wrapping
        hmm1

-- TODO ugh, should use wrappingExt and will need to prove more about
-- encodeTr2Inc/encodeTr1Inc? but essentially easy?
wrappingTr2Ext (p q : Path (Path (tr2 S2) (inc base) (inc base)) (<_> inc base) (<_> inc base))
  (h : Path Z (wrappingTr2 p) (wrappingTr2 q))
  : Path (Path (Path (tr2 S2) (inc base) (inc base)) (<_> inc base) (<_> inc base)) p q
  = undefined



-- Section: J3S1

-- Now we will start to use the word-length filtrations of James
-- constructions. I will use "reduced" versions but they should be
-- equivalent to Brunerie's...

-- First we need J3S1. This models ΩS2 up to 2-truncation. We can use
-- it to compute elemenst of pi3S2, but here I actually need it for
-- the "awful" computation at the end.
data J3S1
  = base
  | loop1 <i>
      [ (i=0) -> base
      , (i=1) -> base
      ]
  | loop2 <i j>
      [ (i=0) -> loop1{J3S1} @ j
      , (i=1) -> loop1{J3S1} @ j
      , (j=0) -> loop1{J3S1} @ i
      , (j=1) -> loop1{J3S1} @ i
      ]
  | loop3 <i j k>
      [ (i=0) -> loop2{J3S1} @ j @ k
      , (i=1) -> loop2{J3S1} @ j @ k
      , (j=0) -> loop2{J3S1} @ i @ k
      , (j=1) -> loop2{J3S1} @ i @ k
      , (k=0) -> loop2{J3S1} @ i @ j
      , (k=1) -> loop2{J3S1} @ i @ j
      ]

-- We want to define pi2J3S1 -> pi2S2 -> Z. The main ingredient is
-- this map, using "ccube" from above. (Is "writhe" an appropriate
-- name? I am not sure yet.)

writhe : J3S1 -> S2 = split
  base -> base
  loop1 @ i -> base
  loop2 @ i j -> loop2{S2} @ i @ j
  loop3 @ i j k -> ccube S2 base (<i j> loop2{S2} @ i @ j) @ i @ j @ k

-- To define the map JS1 -> tr2 J3S1 we can define "loops" in tr2 J3S1

loopsJ3S1' : (x : J3S1) -> Path (tr2 J3S1) (inc x) (inc x) = split
  base -> <l> inc (loop1{J3S1} @ l)
  loop1 @ i -> <l> inc (loop2{J3S1} @ i @ l)
  loop2 @ i j -> <l> inc (loop3{J3S1} @ i @ j @ l)
  loop3 @ i j k -> TODO @ i @ j @ k
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> Path (tr2 J3S1)
                                                 (inc (loop3{J3S1} @ i @ j @ k))
                                                 (inc (loop3{J3S1} @ i @ j @ k)))
                                       (<l> inc (loop3{J3S1} @ i @ j @ l))
                                       (<l> inc (loop3{J3S1} @ i @ j @ l)))
                            (<k l> inc (loop3{J3S1} @ i @ k @ l))
                            (<k l> inc (loop3{J3S1} @ i @ k @ l)))
                 (<j k l> inc (loop3{J3S1} @ j @ k @ l))
                 (<j k l> inc (loop3{J3S1} @ j @ k @ l))
      = undefined

loopsJ3S1 : (x : tr2 J3S1) -> Path (tr2 J3S1) x x
  = elimTr2 J3S1 (\(x : tr2 J3S1) -> Path (tr2 J3S1) x x)
      (\(x : tr2 J3S1) ->
          idfun (twogroupoid (Path (tr2 J3S1) x x))
                (groupoidTwogroupoid
                  (Path (tr2 J3S1) x x)
                  (twogroupoidTr2 J3S1 x x)))
      loopsJ3S1'

-- Actually we don't need this map here:

-- toJ3S1 : JS1 -> tr2 J3S1 = split
--   base -> inc base
--   loops x @ i -> loopsJ3S1 (toJ3S1 x) @ i

-- Instead we need an equivalence:

--     tr2 J3S1 ~= S1 x tr2 S2

-- which we can define directly. I am going to define both homotopies
-- even though we only need one of them (psiPhi) below.

phi1' : J3S1 -> S1 = split
  base -> base
  loop1 @ i -> loop1{S1} @ i
  loop2 @ i j -> rotLoop (rotLoop base @ i) @ j
  loop3 @ i j k -> TODO @ i @ j @ k
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> S1)
                                       (rotLoop (rotLoop base @ i) @ j)
                                       (rotLoop (rotLoop base @ i) @ j))
                            (<k> rotLoop (rotLoop base @ i) @ k)
                            (<k> rotLoop (rotLoop base @ i) @ k))
                 (<j k> rotLoop (rotLoop base @ j) @ k)
                 (<j k> rotLoop (rotLoop base @ j) @ k)
      = undefined

phi2' : J3S1 -> S2 = writhe

psiBase : S2 -> J3S1 = split
  base -> base
  loop2 @ i j ->
    csqInv J3S1
      base base base
      (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
      (<i j> loop2{J3S1} @ i @ j)
      @ i @ j

psi'' : S1 -> S2 -> tr2 J3S1 = split
  base -> \(y : S2) -> inc (psiBase y)
  loop1 @ i -> \(y : S2) -> loopsJ3S1 (inc (psiBase y)) @ i

phi1 : tr2 J3S1 -> S1
  = recTr2 J3S1 S1
      (groupoidTwogroupoid S1 groupoidS1)
      phi1'

phi2 : tr2 J3S1 -> tr2 S2
  = mapTr2 J3S1 S2 phi2'

phi (x : tr2 J3S1) : (_ : S1) * tr2 S2 =
  (phi1 x, phi2 x)

psi' (x : S1) : tr2 S2 -> tr2 J3S1
  = recTr2 S2 (tr2 J3S1)
      (twogroupoidTr2 J3S1)
      (\(y : S2) -> psi'' x y)

psi (x : (_ : S1) * tr2 S2) : tr2 J3S1
  = psi' x.1 x.2

phi1PsiBase : (y : S2) -> Path S1 (phi1' (psiBase y)) base = split
  base -> <_> base
  loop2 @ i j -> TODO @ i @ j
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> Path S1 (phi1' (psiBase (loop2{S2} @ i @ j))) base)
                            (<_> base)
                            (<_> base))
                 (<_ _> base)
                 (<_ _> base)
      = undefined

phi1PsiLoop : (y : S2) -> PathP (<k> Path S1 (phi1 (psi'' (loop1{S1} @ k) y)) (loop1{S1} @ k))
                                (phi1PsiBase y)
                                (phi1PsiBase y) = split
  base -> <k _> loop1{S1} @ k
  loop2 @ i j -> TODO @ i @ j
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> Path S1 (phi1 (psi'' (loop1{S1} @ k) (loop2{S2} @ i @ j))) (loop1{S1} @ k))
                                       (phi1PsiBase (loop2{S2} @ i @ j))
                                       (phi1PsiBase (loop2{S2} @ i @ j)))
                            (<k _> loop1{S1} @ k)
                            (<k _> loop1{S1} @ k))
                 (<_ k _> loop1{S1} @ k)
                 (<_ k _> loop1{S1} @ k)
      = undefined

phi1Psi : (x : S1) (y : S2) -> Path S1 (phi1 (psi'' x y)) x = split
  base -> phi1PsiBase
  loop1 @ i -> \(y : S2) -> phi1PsiLoop y @ i

phi2PsiBase : (y : S2) -> Path (tr2 S2) (inc (phi2' (psiBase y))) (inc y) = split
  base -> <_> inc base
  loop2 @ i j -> <k> inc (hfill S2
                                (loop2{S2} @ i @ j)
                                [ (i=0) -> <_> base
                                , (i=1) -> <_> base
                                , (j=0) -> <_> base
                                , (j=1) -> <_> base
                                ]
                                @ -k)

phi2PsiLoop : (y : S2) ->
  PathP (<i> Path (tr2 S2) (phi2 (psi' (loop1{S1} @ i) (inc y))) (inc y))
        (phi2PsiBase y)
        (phi2PsiBase y) = split
  base -> <_ _> inc base
  loop2 @ i j -> TODO @ i @ j
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> Path (tr2 S2)
                                                 (phi2 (psi' (loop1{S1} @ k) (inc (loop2{S2} @ i @ j))))
                                                 (inc (loop2{S2} @ i @ j)))
                                       (phi2PsiBase (loop2{S2} @ i @ j))
                                       (phi2PsiBase (loop2{S2} @ i @ j)))
                            (<_ _> inc base)
                            (<_ _> inc base))
                 (<_ _ _> inc base)
                 (<_ _ _> inc base)
      = undefined

phi2Psi : (x : S1) (y : S2) -> Path (tr2 S2) (phi2 (psi'' x y)) (inc y) = split
  base -> phi2PsiBase
  loop1 @ i -> \(y : S2) -> phi2PsiLoop y @ i

phiPsi' (x : S1) : (y : tr2 S2) -> Path ((_ : S1) * tr2 S2) (phi (psi (x, y))) (x, y)
  = elimTr2 S2 (\(y : tr2 S2) -> Path ((_ : S1) * tr2 S2) (phi (psi (x, y))) (x, y))
      TODO
      (\(y : S2) -> <i> (phi1Psi x y @ i, phi2Psi x y @ i))
  where
  -- TODO hlevel
  TODO : (y : tr2 S2) -> twogroupoid (Path ((_ : S1) * tr2 S2) (phi (psi (x, y))) (x, y))
    = undefined

-- We don't actually use this homotopy below.
phiPsi (x : (_ : S1) * tr2 S2) : Path ((_ : S1) * tr2 S2) (phi (psi x)) x
  = phiPsi' x.1 x.2

-- This is the one we need
psiPhi' : (x : J3S1) -> Path (tr2 J3S1) (psi (phi (inc x))) (inc x) = split
  base -> <_> inc base
  loop1 @ i -> <_> inc (loop1{J3S1} @ i)
  loop2 @ i j -> step3 @ i @ j
    where
    -- this is just a "pres" (as in original CCHM paper)
    step1 : PathP (<i> PathP (<j> Path (tr2 J3S1)
                                       (psi (phi (inc (loop2{J3S1} @ i @ j))))
                                       (inc (csq J3S1 base base base (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
                                              (csqInv J3S1 base base base (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
                                                (<i j> loop2{J3S1} @ i @ j))
                                              @ i @ j)))
                             (<_> inc (loop1{J3S1} @ i))
                             (<_> inc (loop1{J3S1} @ i)))
                  (<j _> inc (loop1{J3S1} @ j))
                  (<j _> inc (loop1{J3S1} @ j))
      = <i j k> hcomp (tr2 J3S1)
                      (inc (csqInv J3S1 base base base (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
                             (<i j> loop2{J3S1} @ i @ j)
                             @ i @ j))
                      [ (i=0) -> <l> inc (loop1{J3S1} @ j \/ -l)
                      , (i=1) -> <l> inc (loop1{J3S1} @ j /\ l)
                      , (j=0) -> <l> inc (loop1{J3S1} @ i \/ -l)
                      , (j=1) -> <l> inc (loop1{J3S1} @ i /\ l)
                      , (k=1) -> <l> inc (csqFill J3S1 base base base (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
                                           (csqInv J3S1 base base base (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
                                             (<i j> loop2{J3S1} @ i @ j))
                                           @ l @ i @ j)
                      ]

    step2 : PathP (<i> PathP (<j> Path (tr2 J3S1)
                                       (inc (csq J3S1 base base base (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
                                              (csqInv J3S1 base base base (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
                                                (<i j> loop2{J3S1} @ i @ j))
                                              @ i @ j))
                                       (inc (loop2{J3S1} @ i @ j)))
                             (<_> inc (loop1{J3S1} @ i))
                             (<_> inc (loop1{J3S1} @ i)))
                  (<j _> inc (loop1{J3S1} @ j))
                  (<j _> inc (loop1{J3S1} @ j))
      = <i j l> inc (csqRightInv J3S1 base base base (<i> loop1{J3S1} @ i) (<i> loop1{J3S1} @ i)
                      (<i j> loop2{J3S1} @ i @ j)
                      @ l @ i @ j)

    step3 : PathP (<i> PathP (<j> Path (tr2 J3S1)
                                       (psi (phi (inc (loop2{J3S1} @ i @ j))))
                                       (inc (loop2{J3S1} @ i @ j)))
                             (<_> inc (loop1{J3S1} @ i))
                             (<_> inc (loop1{J3S1} @ i)))
                  (<j _> inc (loop1{J3S1} @ j))
                  (<j _> inc (loop1{J3S1} @ j))
      = transGen (<f> PathP (<i> PathP (<j> Path (tr2 J3S1)
                                                 (step1 @ i @ j @ -f)
                                                 (inc (loop2{J3S1} @ i @ j)))
                                       (<_> inc (loop1{J3S1} @ i))
                                       (<_> inc (loop1{J3S1} @ i)))
                            (<j _> inc (loop1{J3S1} @ j))
                            (<j _> inc (loop1{J3S1} @ j)))
                 0
                 step2
  loop3 @ i j k -> TODO @ i @ j @ k
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> Path (tr2 J3S1)
                                                 (psi'' (phi1' (loop3{J3S1} @ i @ j @ k)) (phi2' (loop3{J3S1} @ i @ j @ k)))
                                                 (inc (loop3{J3S1} @ i @ j @ k)))
                                       (psiPhi' (loop2{J3S1} @ i @ j))
                                       (psiPhi' (loop2{J3S1} @ i @ j)))
                            (<k> psiPhi' (loop2{J3S1} @ i @ k))
                            (<k> psiPhi' (loop2{J3S1} @ i @ k)))
                 (<j k> psiPhi' (loop2{J3S1} @ j @ k))
                 (<j k> psiPhi' (loop2{J3S1} @ j @ k))
      = undefined

psiPhi : (x : tr2 J3S1) -> Path (tr2 J3S1) (psi (phi x)) x
  = elimTr2 J3S1
      (\(x : tr2 J3S1) -> Path (tr2 J3S1) (psi (phi x)) x)
      (\(x : tr2 J3S1) ->
        groupoidTwogroupoid
          (Path (tr2 J3S1) (psi (phi x)) x)
          (twogroupoidTr2 J3S1 (psi (phi x)) x))
      psiPhi'

-- OK, so we have an isomorphism ||J3S1||2 ~= S1 x ||S2||2

-- Using psiPhi we get equalities in pi2J3S1 from equalities in pi2S2:

surftrJ3S1Ext
  (p q : Path (Path (tr2 J3S1) (inc base) (inc base)) (<_> inc base) (<_> inc base))
  (h : Path (Path (Path (tr2 S2) (inc base) (inc base)) (<_> inc base) (<_> inc base))
            (<i j> phi2 (p @ i @ j))
            (<i j> phi2 (q @ i @ j)))
  : Path (Path (Path (tr2 J3S1) (inc base) (inc base)) (<_> inc base) (<_> inc base))
         p q
  = step2
  where
  hS1 : Path (Path (Path S1 base base) (<_> base) (<_> base))
             (<i j> phi1 (p @ i @ j))
             (<i j> phi1 (q @ i @ j))
    = groupoidS1 base base (<_> base) (<_> base) (<i j> phi1 (p @ i @ j)) (<i j> phi1 (q @ i @ j))

  step1 : Path (Path (Path (tr2 J3S1) (inc base) (inc base)) (<_> inc base) (<_> inc base))
               (<i j> psi (phi (p @ i @ j)))
               (<i j> psi (phi (q @ i @ j)))
    = <k i j> psi' (hS1 @ k @ i @ j) (h @ k @ i @ j)

  step2 : Path (Path (Path (tr2 J3S1) (inc base) (inc base)) (<_> inc base) (<_> inc base))
               p q
    = <k> hcomp (Path (Path (tr2 J3S1) (inc base) (inc base)) (<_> inc base) (<_> inc base))
                (step1 @ k)
                [ (k=0) -> <k i j> psiPhi (p @ i @ j) @ k
                , (k=1) -> <k i j> psiPhi (q @ i @ j) @ k
                ]

opaque surftrJ3S1Ext



-- Section: J2S2

-- Now we have arrived at the destination.

-- J2S2 models ΩS3 up to 4-truncation (up to pi4J2S2 ~= pi5S3.) It is
-- our first step for π4S3
data J2S2
  = base
  | loop2 <i j>
    [ (i=0) -> base
    , (i=1) -> base
    , (j=0) -> base
    , (j=1) -> base
    ]
  | loop4 <i j k l>
    [ (i=0) -> loop2{J2S2} @ k @ l
    , (i=1) -> loop2{J2S2} @ k @ l
    , (j=0) -> loop2{J2S2} @ k @ l
    , (j=1) -> loop2{J2S2} @ k @ l
    , (k=0) -> loop2{J2S2} @ i @ j
    , (k=1) -> loop2{J2S2} @ i @ j
    , (l=0) -> loop2{J2S2} @ i @ j
    , (l=1) -> loop2{J2S2} @ i @ j
    ]

-- This "LJ2S2" should model ΩJ2S2 up to 2-truncation, I think. Notice
-- that it is like J3S1 with an extra 3-cell (loop2Inv) which glues
-- loop2 to its transpose. It was obtained by taking a kind of
-- word-length filtration of a James-ish construction for ΩJ2S2, which
-- says that ΩJ2S2 is like JS1 with a recursive 3-path constructor
-- corresponding to "loopInv." I have not verified yet whether this
-- actually works, as I cannot even prove the "2+2" lemma yet which
-- seems to justify it (see below.)

-- There should be a model up to 3-truncation with 3(?) extra 4-cells,
-- which provides some information about pi5S3, but I don't understand
-- it at all yet.
data LJ2S2
  = base
  | loop1 <a>
      [ (a=0) -> base
      , (a=1) -> base
      ]
  | loop2 <a b>
      [ (a=0) -> loop1{LJ2S2} @ b
      , (a=1) -> loop1{LJ2S2} @ b
      , (b=0) -> loop1{LJ2S2} @ a
      , (b=1) -> loop1{LJ2S2} @ a
      ]
  | loop3 <a b c>
      [ (a=0) -> loop2{LJ2S2} @ b @ c
      , (a=1) -> loop2{LJ2S2} @ b @ c
      , (b=0) -> loop2{LJ2S2} @ a @ c
      , (b=1) -> loop2{LJ2S2} @ a @ c
      , (c=0) -> loop2{LJ2S2} @ a @ b
      , (c=1) -> loop2{LJ2S2} @ a @ b
      ]
  | loop2Inv <a b c>
      [ (a=0) -> loop2{LJ2S2} @ b @ c
      , (a=1) -> loop2{LJ2S2} @ c @ b -- !
      , (b=0) -> loop1{LJ2S2} @ c
      , (b=1) -> loop1{LJ2S2} @ c
      , (c=0) -> loop1{LJ2S2} @ b
      , (c=1) -> loop1{LJ2S2} @ b
      ]

-- We will need to do "loops" again on the 2-truncation of this type;
-- this is similar to loopsJ3S1, and the case for the extra 3-cell is
-- trivial by hlevel

loopsLJ2S2' : (x : LJ2S2) -> Path (tr2 LJ2S2) (inc x) (inc x) = split
  base -> <l> inc (loop1{LJ2S2} @ l)
  loop1 @ i -> <l> inc (loop2{LJ2S2} @ i @ l)
  loop2 @ i j -> <l> inc (loop3{LJ2S2} @ i @ j @ l)
  loop3 @ i j k -> TODO @ i @ j @ k
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> Path (tr2 LJ2S2)
                                                 (inc (loop3{LJ2S2} @ i @ j @ k))
                                                 (inc (loop3{LJ2S2} @ i @ j @ k)))
                                       (<l> inc (loop3{LJ2S2} @ i @ j @ l))
                                       (<l> inc (loop3{LJ2S2} @ i @ j @ l)))
                            (<k l> inc (loop3{LJ2S2} @ i @ k @ l))
                            (<k l> inc (loop3{LJ2S2} @ i @ k @ l)))
                 (<j k l> inc (loop3{LJ2S2} @ j @ k @ l))
                 (<j k l> inc (loop3{LJ2S2} @ j @ k @ l))
      = undefined
  loop2Inv @ k i j -> TODO @ k @ i @ j
    where
    -- TODO by hlevel
    TODO : PathP (<k> PathP (<i> PathP (<j> Path (tr2 LJ2S2)
                                                 (inc (loop2Inv{LJ2S2} @ k @ i @ j))
                                                 (inc (loop2Inv{LJ2S2} @ k @ i @ j)))
                                       (<l> inc (loop2{LJ2S2} @ i @ l))
                                       (<l> inc (loop2{LJ2S2} @ i @ l)))
                            (<j l> inc (loop2{LJ2S2} @ j @ l))
                            (<j l> inc (loop2{LJ2S2} @ j @ l)))
                 (<i j l> inc (loop3{LJ2S2} @ i @ j @ l))
                 (<i j l> inc (loop3{LJ2S2} @ j @ i @ l))
      = undefined

loopsLJ2S2 : (x : tr2 LJ2S2) -> Path (tr2 LJ2S2) x x
  = elimTr2 LJ2S2 (\(x : tr2 LJ2S2) -> Path (tr2 LJ2S2) x x)
      (\(x : tr2 LJ2S2) ->
          groupoidTwogroupoid
            (Path (tr2 LJ2S2) x x)
            (twogroupoidTr2 LJ2S2 x x))
      loopsLJ2S2'

-- Ok, now, the hard part: let's map ΩJ2S2 -> tr2 LJ2S2. To do this we
-- need to define a fibration J2S2 -> U sending the basepoint to
-- tr2 LJ2S2. The case for the 2-cell in J2S2 is just
-- `global loopsLJ2S2`, but the 4-cell is problematic.

-- The type of the problematic 4-cell:
fourCell (A : U) (H : Path (Path U A A) (<_> A) (<_> A)) : U
  = PathP (<i> PathP (<j> PathP (<a> PathP (<b> U)
                                           (H @ i @ j)
                                           (H @ i @ j))
                                (<_> H @ i @ j)
                                (<_> H @ i @ j))
                     (<a b> H @ a @ b)
                     (<a b> H @ a @ b))
          (<_ a b> H @ a @ b)
          (<_ a b> H @ a @ b)

-- I conjecture that there is a map which constructs these 4-cells
-- from "local" data like this:

-- twoPlusTwo (A : U) (H : Path (Path U A A) (<_> A) (<_> A))
--   : ((x : A) -> Path (PathP (<i> PathP (<j> A) (local A H x @ i) (local A H x @ i))
--                             (<j> local A H x @ j)
--                             (<j> local A H x @ j))
--                      (<i j> local A H (local A H x @ i) @ j)
--                      (<i j> local A H (local A H x @ j) @ i)) -- transposed!
--   -> fourCell A H
--   = undefined

-- ...and that this map is an equivalence (for each H.) Actually, the
-- lemma should probably be stated the other way around, since the
-- other direction appears to be the easy direction. But the hard
-- direction (as in twoPlusTwo) is what we need below.

-- However, as suggested to me by Axel Ljungström, we can just prove
-- the special case we need, for LJ2S2. We start with this "two" thing
-- which is related to J2S2 and the Brunerie number.

two (A : U) (x : A) (s : Path (Path A x x) (<_> x) (<_> x))
  : Path (Path (Path A x x) (<_> x) (<_> x)) s s
  = <j a b> hcomp A
                  (s @ a @ b)
                  [ (j=0) -> <_> s @ a @ b
                  , (j=1) -> <_> s @ a @ b
                  , (a=0) -> <i> s @ i @ j
                  , (a=1) -> <i> s @ i @ j
                  , (b=0) -> <i> s @ i @ j
                  , (b=1) -> <i> s @ i @ j
                  ]

twoFill (A : U) (x : A) (s : Path (Path A x x) (<_> x) (<_> x))
  : PathP (<i> PathP (<j> PathP (<a> PathP (<b> A) (s @ i @ j) (s @ i @ j))
                                (<_> s @ i @ j)
                                (<_> s @ i @ j))
                     (<a b> s @ a @ b)
                     (<a b> s @ a @ b))
          (<_ a b> s @ a @ b)
          (<j a b> two A x s @ j @ a @ b)
  = <i j a b> hfill A
                (s @ a @ b)
                [ (j=0) -> <_> s @ a @ b
                , (j=1) -> <_> s @ a @ b
                , (a=0) -> <i> s @ i @ j
                , (a=1) -> <i> s @ i @ j
                , (b=0) -> <i> s @ i @ j
                , (b=1) -> <i> s @ i @ j
                ]
                @ i

-- This "two" thing is related to the problematic 4-cell type:
-- essentially, the 4-cell says that two is zero (refl)...
twoTranspLemma1 (A : U) (x : A) (s : Path (Path A x x) (<_> x) (<_> x))
  : Path (Path (Path (Path A x x) (<_> x) (<_> x)) s s)
         (transGen (<i> PathP (<j> PathP (<a> PathP (<b> A) (s @ i @ j) (s @ i @ j))
                                         (<_> s @ i @ j)
                                         (<_> s @ i @ j))
                              (<a b> s @ a @ b)
                              (<a b> s @ a @ b))
                   0
                   (<_ a b> s @ a @ b))
         (two A x s)
  = <i j a b> hcomp A
                (s @ a @ b)
                -- transpFill:
                [ (i=0) -> <k> transGen (<i> PathP (<j> PathP (<a> PathP (<b> A) (s @ i /\ k @ j) (s @ i /\ k @ j))
                                                              (<_> s @ i /\ k @ j)
                                                              (<_> s @ i /\ k @ j))
                                                   (<a b> s @ a @ b)
                                                   (<a b> s @ a @ b))
                                        -k
                                        (<_ a b> s @ a @ b)
                                        @ j @ a @ b
                , (i=1) -> <k> twoFill A x s @ k @ j @ a @ b
                , (j=0) -> <k> s @ a @ b
                , (j=1) -> <k> s @ a @ b
                , (a=0) -> <k> s @ k @ j
                , (a=1) -> <k> s @ k @ j
                , (b=0) -> <k> s @ k @ j
                , (b=1) -> <k> s @ k @ j
                ]

toPathPPath (A0 A1 : U) (A : PathP (<i> U) A0 A1)
  (x : A0) (y : A1)
  : Path U (PathP (<i> A @ i) x y)
           (Path A1 (transGen (<i> A @ i) 0 x) y)
  = <k> PathP (<i> A @ i \/ k) (transGen (<i> A @ i /\ k) -k x) y

-- So the following suffices for constructing the problematic
-- 4-cell. But I still can't prove this in general.

twoTranspLemma2 (A : U) (H : Path (Path U A A) (<_> A) (<_> A))
  (hyp : (x : A) -> Path (Path (Path A x x) (local A H x) (local A H x))
                         (<i j> local A (two U A H @ i) x @ j)
                         (<_ j> local A H x @ j))
  : fourCell A H
  = step2
  where
  step1 : Path (Path (Path (Path U A A) (<_> A) (<_> A)) H H) (two U A H) (<_> H)
    = loopGlobalEq A H
        (two U A H)
        (<_> H)
        hyp

  step2 : fourCell A H
    = transGen (<k> toPathPPath
                      (Path (Path (Path U A A) (<_> A) (<_> A)) H H)
                      (Path (Path (Path U A A) (<_> A) (<_> A)) H H)
                      (<i> PathP (<j> PathP (<a> PathP (<b> U) (H @ i @ j) (H @ i @ j))
                                            (<_> H @ i @ j)
                                            (<_> H @ i @ j))
                                 (<a b> H @ a @ b)
                                 (<a b> H @ a @ b))
                      (<j a b> H @ a @ b)
                      (<j a b> H @ a @ b)
                      @ -k)
               0
               step1

opaque twoTranspLemma2

-- So, this is our problem.

Problem (A : U) (h : Local A) (x : A) : U =
  Path (Path (Path A x x)
             (local A (global A h) x)
             (local A (global A h) x))
       (<i j> local A (two U A (global A h) @ i) x @ j)
       (<_ j> local A (global A h) x @ j)

-- If we normalize this on tr2 LJ2S2 and generalize slightly, we get
-- the following problem, which is big, but simpler than the general
-- case.

SIDE (A : U) (x : A)
  (loop1 : Path A x x)
  : Path (tr2 A) (inc x) (inc x)
  = <i60057> hcomp (tr2 A)
                   (hcomp (tr2 A)
                          (inc (loop1 @ i60057))
                          [(i60057=0) -> <i60059> inc x, (i60057=1) -> <i60059> inc x])
                   [(i60057=0) -> <i60060> inc x, (i60057=1) -> <i60060> inc x]

-- a big 2-cell
BIG (A : U) (x : A)
  (loop1 : Path A x x)
  -- the thing has 2 occurrences of the "loop2" 2-cell; it will be
  -- useful to generalize over them:
  (loop2a loop2b : PathP (<i> Path A (loop1 @ i) (loop1 @ i)) loop1 loop1)
  : Path (Path (tr2 A) (inc x) (inc x))
         (SIDE A x loop1)
         (SIDE A x loop1)
  -- sorry no way am I pretty-printing this by hand ;)
  -- it would be nice to extract all the common subexpressions in here
  -- maybe?
  = <i60065 i60066> hcomp (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A) (hcomp
  (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A)
  (inc (loop1 @ i60066)) [(i60066=0) -> <i60076> hcomp (tr2 A) (inc x)
  [(i60076=0) -> <i60077> inc x, (i60065=0) -> <i60077> inc (loop1 @
  (-i60076 \/ -i60077)), (i60065=1) -> <i60077> inc x], (i60066=1) ->
  <i60076> hcomp (tr2 A) (inc x) [(i60076=0) -> <i60077> inc x,
  (i60065=0) -> <i60077> inc (loop1 @ (-i60076 \/ -i60077)),
  (i60065=1) -> <i60077> inc x], (i60065=0) -> <i60076> inc (loop2a @
  -i60076 @ i60066), (i60065=1) -> <i60076> inc (loop1 @ i60066)])
  [(i60066=0) -> <i60073> hcomp (tr2 A) (hcomp (tr2 A) (inc x)
  [(i60065=0) -> <i60075> inc (loop1 @ -i60075), (i60065=1) ->
  <i60075> inc x]) [(i60073=0) -> <i60078> hcomp (tr2 A) (inc x)
  [(i60065=0) -> <i60075> inc (loop1 @ -i60075), (i60065=1) ->
  <i60075> inc x], (i60065=0) -> <i60078> inc x, (i60065=1) ->
  <i60078> inc x], (i60066=1) -> <i60073> hcomp (tr2 A) (hcomp (tr2 A)
  (inc x) [(i60065=0) -> <i60075> inc (loop1 @ -i60075), (i60065=1) ->
  <i60075> inc x]) [(i60073=0) -> <i60078> hcomp (tr2 A) (inc x)
  [(i60065=0) -> <i60075> inc (loop1 @ -i60075), (i60065=1) ->
  <i60075> inc x], (i60065=0) -> <i60078> inc x, (i60065=1) ->
  <i60078> inc x], (i60065=0) -> <i60073> inc (loop1 @ i60066),
  (i60065=1) -> <i60073> inc (loop1 @ i60066)]) [(i60066=0) ->
  <i60080> hcomp (tr2 A) (hcomp (tr2 A) (inc x) [(i60065=0) ->
  <i60075> inc (loop1 @ -i60075), (i60065=1) -> <i60075> inc x])
  [(i60065=0) -> <i60072> inc x, (i60065=1) -> <i60072> inc x],
  (i60066=1) -> <i60080> hcomp (tr2 A) (hcomp (tr2 A) (inc x)
  [(i60065=0) -> <i60075> inc (loop1 @ -i60075), (i60065=1) ->
  <i60075> inc x]) [(i60065=0) -> <i60072> inc x, (i60065=1) ->
  <i60072> inc x]]) [(i60066=0) -> <i60082> hcomp (tr2 A) (hcomp (tr2
  A) (inc x) [(i60065=0) -> <i60075> inc (loop1 @ -i60075), (i60065=1)
  -> <i60075> inc x]) [(i60065=0) -> <i60072> inc x, (i60065=1) ->
  <i60072> inc x], (i60066=1) -> <i60082> hcomp (tr2 A) (hcomp (tr2 A)
  (inc x) [(i60065=0) -> <i60075> inc (loop1 @ -i60075), (i60065=1) ->
  <i60075> inc x]) [(i60065=0) -> <i60072> inc x, (i60065=1) ->
  <i60072> inc x]]) [(i60065=0) -> <i60083> hcomp (tr2 A) (hcomp (tr2
  A) (hcomp (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A) (inc
  (loop1 @ i60066)) [(i60066=0) -> <i60091> inc x, (i60066=1) ->
  <i60091> inc x, (i60083=0) -> <i60091> inc (loop1 @ i60066)])
  [(i60083=1) -> <i60090> hcomp (tr2 A) (hcomp (tr2 A) (inc (loop1 @
  i60066)) [(i60066=0) -> <i60091> inc x, (i60066=1) -> <i60091> inc
  x]) [(i60090=0) -> <i60094> hcomp (tr2 A) (inc (loop1 @ i60066))
  [(i60066=0) -> <i60091> inc x, (i60066=1) -> <i60091> inc x],
  (i60090=1) -> <i60094> hcomp (tr2 A) (hcomp (tr2 A) (inc (loop1 @
  i60066)) [(i60066=0) -> <i60091> inc x, (i60066=1) -> <i60091> inc
  x]) [(i60094=0) -> <i60095> hcomp (tr2 A) (inc (loop1 @ i60066))
  [(i60066=0) -> <i60091> inc x, (i60066=1) -> <i60091> inc x],
  (i60066=0) -> <i60095> inc x, (i60066=1) -> <i60095> inc x],
  (i60066=0) -> <i60094> inc x, (i60066=1) -> <i60094> inc x],
  (i60066=1) -> <i60090> inc x, (i60066=0) -> <i60090> inc x,
  (i60083=0) -> <i60090> inc (loop1 @ i60066)]) [(i60066=0) ->
  <i60089> inc x, (i60066=1) -> <i60089> inc x, (i60083=0) -> <i60089>
  inc (loop1 @ i60066), (i60083=1) -> <i60089> hcomp (tr2 A) (hcomp
  (tr2 A) (inc (loop1 @ i60066)) [(i60066=0) -> <i60091> inc x,
  (i60066=1) -> <i60091> inc x]) [(i60066=0) -> <i60093> inc x,
  (i60066=1) -> <i60093> inc x]]) [(i60066=0) -> <i60088> inc x,
  (i60066=1) -> <i60088> inc x, (i60083=0) -> <i60088> inc (loop1 @
  i60066), (i60083=1) -> <i60088> hcomp (tr2 A) (hcomp (tr2 A) (inc
  (loop1 @ i60066)) [(i60066=0) -> <i60091> inc x, (i60066=1) ->
  <i60091> inc x]) [(i60066=0) -> <i60093> inc x, (i60066=1) ->
  <i60093> inc x]]) [(i60066=0) -> <i60127> inc x, (i60066=1) ->
  <i60127> inc x, (i60083=1) -> <i60127> hcomp (tr2 A) (hcomp (tr2 A)
  (inc (loop1 @ i60066)) [(i60066=0) -> <i60091> inc x, (i60066=1) ->
  <i60091> inc x]) [(i60066=0) -> <i60093> inc x, (i60066=1) ->
  <i60093> inc x]]) [(i60066=0) -> <i60128> inc x, (i60066=1) ->
  <i60128> inc x, (i60083=1) -> <i60128> hcomp (tr2 A) (hcomp (tr2 A)
  (inc (loop1 @ i60066)) [(i60066=0) -> <i60091> inc x, (i60066=1) ->
  <i60091> inc x]) [(i60066=0) -> <i60093> inc x, (i60066=1) ->
  <i60093> inc x]], (i60065=1) -> <i60083> hcomp (tr2 A) (hcomp (tr2
  A) (hcomp (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A) (inc
  (loop1 @ i60066)) [(i60066=0) -> <i60136> inc x, (i60066=1) ->
  <i60136> inc x, (i60083=0) -> <i60136> inc (loop1 @ i60066)])
  [(i60083=1) -> <i60135> hcomp (tr2 A) (hcomp (tr2 A) (inc (loop1 @
  i60066)) [(i60066=0) -> <i60136> inc x, (i60066=1) -> <i60136> inc
  x]) [(i60135=0) -> <i60139> hcomp (tr2 A) (inc (loop1 @ i60066))
  [(i60066=0) -> <i60136> inc x, (i60066=1) -> <i60136> inc x],
  (i60135=1) -> <i60139> hcomp (tr2 A) (hcomp (tr2 A) (inc (loop1 @
  i60066)) [(i60066=0) -> <i60136> inc x, (i60066=1) -> <i60136> inc
  x]) [(i60139=0) -> <i60140> hcomp (tr2 A) (inc (loop1 @ i60066))
  [(i60066=0) -> <i60136> inc x, (i60066=1) -> <i60136> inc x],
  (i60066=0) -> <i60140> inc x, (i60066=1) -> <i60140> inc x],
  (i60066=0) -> <i60139> inc x, (i60066=1) -> <i60139> inc x],
  (i60066=1) -> <i60135> inc x, (i60066=0) -> <i60135> inc x,
  (i60083=0) -> <i60135> inc (loop1 @ i60066)]) [(i60066=0) ->
  <i60134> inc x, (i60066=1) -> <i60134> inc x, (i60083=0) -> <i60134>
  inc (loop1 @ i60066), (i60083=1) -> <i60134> hcomp (tr2 A) (hcomp
  (tr2 A) (inc (loop1 @ i60066)) [(i60066=0) -> <i60136> inc x,
  (i60066=1) -> <i60136> inc x]) [(i60066=0) -> <i60138> inc x,
  (i60066=1) -> <i60138> inc x]]) [(i60066=0) -> <i60133> inc x,
  (i60066=1) -> <i60133> inc x, (i60083=0) -> <i60133> inc (loop1 @
  i60066), (i60083=1) -> <i60133> hcomp (tr2 A) (hcomp (tr2 A) (inc
  (loop1 @ i60066)) [(i60066=0) -> <i60136> inc x, (i60066=1) ->
  <i60136> inc x]) [(i60066=0) -> <i60138> inc x, (i60066=1) ->
  <i60138> inc x]]) [(i60066=0) -> <i60172> inc x, (i60066=1) ->
  <i60172> inc x, (i60083=1) -> <i60172> hcomp (tr2 A) (hcomp (tr2 A)
  (inc (loop1 @ i60066)) [(i60066=0) -> <i60136> inc x, (i60066=1) ->
  <i60136> inc x]) [(i60066=0) -> <i60138> inc x, (i60066=1) ->
  <i60138> inc x]]) [(i60066=0) -> <i60173> inc x, (i60066=1) ->
  <i60173> inc x, (i60083=1) -> <i60173> hcomp (tr2 A) (hcomp (tr2 A)
  (inc (loop1 @ i60066)) [(i60066=0) -> <i60136> inc x, (i60066=1) ->
  <i60136> inc x]) [(i60066=0) -> <i60138> inc x, (i60066=1) ->
  <i60138> inc x]], (i60066=0) -> <i60083> hcomp (tr2 A) (hcomp (tr2
  A) (inc x) [(i60065=0) -> <i60176> inc (loop1 @ -i60176), (i60065=1)
  -> <i60176> inc x]) [(i60065=0) -> <i60175> inc x, (i60065=1) ->
  <i60175> inc x], (i60066=1) -> <i60083> hcomp (tr2 A) (hcomp (tr2 A)
  (inc x) [(i60065=0) -> <i60179> inc (loop1 @ -i60179), (i60065=1) ->
  <i60179> inc x]) [(i60065=0) -> <i60178> inc x, (i60065=1) ->
  <i60178> inc x]]) [(i60065=0) -> <i60184> hcomp (tr2 A) (hcomp (tr2
  A) (inc (loop2b @ i60066 @ i60184)) [(i60184=0) -> <i60183> hcomp
  (tr2 A) (inc (loop1 @ i60066)) [(i60183=0) -> <i60186> inc (loop1 @
  i60066), (i60066=0) -> <i60186> inc x, (i60066=1) -> <i60186> inc
  x], (i60184=1) -> <i60183> hcomp (tr2 A) (inc (loop1 @ i60066))
  [(i60183=0) -> <i60186> inc (loop1 @ i60066), (i60066=0) -> <i60186>
  inc x, (i60066=1) -> <i60186> inc x], (i60066=0) -> <i60183> inc
  (loop1 @ i60184), (i60066=1) -> <i60183> inc (loop1 @ i60184)])
  [(i60184=0) -> <i60181> hcomp (tr2 A) (hcomp (tr2 A) (inc (loop1 @
  i60066)) [(i60066=0) -> <i60091> inc x, (i60066=1) -> <i60091> inc
  x]) [(i60181=0) -> <i60187> hcomp (tr2 A) (inc (loop1 @ i60066))
  [(i60066=0) -> <i60091> inc x, (i60066=1) -> <i60091> inc x],
  (i60066=0) -> <i60187> inc x, (i60066=1) -> <i60187> inc x],
  (i60184=1) -> <i60181> hcomp (tr2 A) (hcomp (tr2 A) (inc (loop1 @
  i60066)) [(i60066=0) -> <i60091> inc x, (i60066=1) -> <i60091> inc
  x]) [(i60181=0) -> <i60187> hcomp (tr2 A) (inc (loop1 @ i60066))
  [(i60066=0) -> <i60091> inc x, (i60066=1) -> <i60091> inc x],
  (i60066=0) -> <i60187> inc x, (i60066=1) -> <i60187> inc x],
  (i60066=0) -> <i60181> inc (loop1 @ i60184), (i60066=1) -> <i60181>
  inc (loop1 @ i60184)], (i60065=1) -> <i60184> hcomp (tr2 A) (hcomp
  (tr2 A) (inc (loop1 @ i60066)) [(i60066=0) -> <i60136> inc x,
  (i60066=1) -> <i60136> inc x]) [(i60066=0) -> <i60138> inc x,
  (i60066=1) -> <i60138> inc x]]) [(i60065=0) -> <i60189> hcomp (tr2
  A) (hcomp (tr2 A) (inc (loop1 @ i60066)) [(i60066=0) -> <i60091> inc
  x, (i60066=1) -> <i60091> inc x]) [(i60066=0) -> <i60187> inc x,
  (i60066=1) -> <i60187> inc x], (i60065=1) -> <i60189> hcomp (tr2 A)
  (hcomp (tr2 A) (inc (loop1 @ i60066)) [(i60066=0) -> <i60136> inc x,
  (i60066=1) -> <i60136> inc x]) [(i60066=0) -> <i60138> inc x,
  (i60066=1) -> <i60138> inc x]]) [(i60065=0) -> <i60193> hcomp (tr2
  A) (hcomp (tr2 A) (inc (loop1 @ i60066)) [(i60066=0) -> <i60192> inc
  x, (i60066=1) -> <i60192> inc x]) [(i60066=0) -> <i60190> inc x,
  (i60066=1) -> <i60190> inc x], (i60065=1) -> <i60193> hcomp (tr2 A)
  (hcomp (tr2 A) (inc (loop1 @ i60066)) [(i60066=0) -> <i60196> inc x,
  (i60066=1) -> <i60196> inc x]) [(i60066=0) -> <i60194> inc x,
  (i60066=1) -> <i60194> inc x], (i60066=0) -> <i60193> hcomp (tr2 A)
  (hcomp (tr2 A) (hcomp (tr2 A) (hcomp (tr2 A) (inc x) [(i60193=1) ->
  <i60198> inc x, (i60065=0) -> <i60198> inc (loop1 @ (i60193 \/
  -i60198)), (i60065=1) -> <i60198> inc x]) [(i60193=0) -> <i60197>
  hcomp (tr2 A) (hcomp (tr2 A) (inc x) [(i60065=0) -> <i60198> inc
  (loop1 @ -i60198), (i60065=1) -> <i60198> inc x]) [(i60197=0) ->
  <i60201> hcomp (tr2 A) (inc x) [(i60065=0) -> <i60198> inc (loop1 @
  -i60198), (i60065=1) -> <i60198> inc x], (i60197=1) -> <i60201>
  hcomp (tr2 A) (hcomp (tr2 A) (inc x) [(i60065=0) -> <i60198> inc
  (loop1 @ -i60198), (i60065=1) -> <i60198> inc x]) [(i60201=0) ->
  <i60202> hcomp (tr2 A) (inc x) [(i60065=0) -> <i60198> inc (loop1 @
  -i60198), (i60065=1) -> <i60198> inc x], (i60065=0) -> <i60202> inc
  x, (i60065=1) -> <i60202> inc x], (i60065=0) -> <i60201> inc x,
  (i60065=1) -> <i60201> inc x], (i60065=0) -> <i60197> inc (loop1 @
  i60193), (i60065=1) -> <i60197> inc x, (i60193=1) -> <i60197> inc
  x]) [(i60193=1) -> <i60222> inc x, (i60065=0) -> <i60222> inc (loop1
  @ (i60193 \/ i60222)), (i60065=1) -> <i60222> inc x]) [(i60193=1) ->
  <i60223> inc x, (i60065=0) -> <i60223> inc x, (i60065=1) -> <i60223>
  inc x], (i60066=1) -> <i60193> hcomp (tr2 A) (hcomp (tr2 A) (hcomp
  (tr2 A) (hcomp (tr2 A) (inc x) [(i60193=1) -> <i60225> inc x,
  (i60065=0) -> <i60225> inc (loop1 @ (i60193 \/ -i60225)), (i60065=1)
  -> <i60225> inc x]) [(i60193=0) -> <i60224> hcomp (tr2 A) (hcomp
  (tr2 A) (inc x) [(i60065=0) -> <i60225> inc (loop1 @ -i60225),
  (i60065=1) -> <i60225> inc x]) [(i60224=0) -> <i60228> hcomp (tr2 A)
  (inc x) [(i60065=0) -> <i60225> inc (loop1 @ -i60225), (i60065=1) ->
  <i60225> inc x], (i60224=1) -> <i60228> hcomp (tr2 A) (hcomp (tr2 A)
  (inc x) [(i60065=0) -> <i60225> inc (loop1 @ -i60225), (i60065=1) ->
  <i60225> inc x]) [(i60228=0) -> <i60229> hcomp (tr2 A) (inc x)
  [(i60065=0) -> <i60225> inc (loop1 @ -i60225), (i60065=1) ->
  <i60225> inc x], (i60065=0) -> <i60229> inc x, (i60065=1) ->
  <i60229> inc x], (i60065=0) -> <i60228> inc x, (i60065=1) ->
  <i60228> inc x], (i60065=0) -> <i60224> inc (loop1 @ i60193),
  (i60065=1) -> <i60224> inc x, (i60193=1) -> <i60224> inc x])
  [(i60193=1) -> <i60247> inc x, (i60065=0) -> <i60247> inc (loop1 @
  (i60193 \/ i60247)), (i60065=1) -> <i60247> inc x]) [(i60193=1) ->
  <i60248> inc x, (i60065=0) -> <i60248> inc x, (i60065=1) -> <i60248>
  inc x]]

-- the problem: we need to prove that the big 2-cell is equal to refl.
PROBLEM1 (A : U) (x : A)
  (loop1 : Path A x x)
  (loop2a loop2b : PathP (<i> Path A (loop1 @ i) (loop1 @ i)) loop1 loop1)
  : U
  = Path (Path (Path (tr2 A) (inc x) (inc x))
               (SIDE A x loop1)
               (SIDE A x loop1))
         (BIG A x loop1 loop2a loop2b)
         (<_> SIDE A x loop1)

-- Now, we can prove a certain instance of the problem on J3S1, by
-- computation:
problemStep1
  : PROBLEM1
      J3S1
      base
      (<i> loop1{J3S1} @ i)
      (<i j> loop2{J3S1} @ i @ j)
      (<i j> loop2{J3S1} @ j @ i) -- flipped!
  -- TODO why is this so slow??? my first test of this was much
  -- faster, I think...
  = hsqExt
      (tr2 J3S1)
      (inc base)
      (inc base)
      (SIDE J3S1 base (<i> loop1{J3S1} @ i))
      (BIG
         J3S1
         base
         (<i> loop1{J3S1} @ i)
         (<i j> loop2{J3S1} @ i @ j)
         (<i j> loop2{J3S1} @ j @ i))
      (<_> SIDE J3S1 base (<i> loop1{J3S1} @ i))
      (surftrJ3S1Ext
        (hsqInv
          (tr2 J3S1)
          (inc base)
          (inc base)
          (SIDE J3S1 base (<i> loop1{J3S1} @ i))
          (BIG
             J3S1
             base
             (<i> loop1{J3S1} @ i)
             (<i j> loop2{J3S1} @ i @ j)
             (<i j> loop2{J3S1} @ j @ i)))
        (hsqInv
          (tr2 J3S1)
          (inc base)
          (inc base)
          (SIDE J3S1 base (<i> loop1{J3S1} @ i))
          (<_> SIDE J3S1 base (<i> loop1{J3S1} @ i)))
        (wrappingTr2Ext
          (hsqInv
            (tr2 S2)
            (inc base)
            (inc base)
            (SIDE S2 base (<_> base))
            (BIG S2 base (<i> base) (<i j> loop2{S2} @ i @ j) (<i j> loop2{S2} @ j @ i)))
          (hsqInv
            (tr2 S2)
            (inc base)
            (inc base)
            (SIDE S2 base (<_> base))
            (<_> SIDE S2 base (<_> base)))
          -- the magic:
          (<_> pos zero)))

-- This gives us something in LJ2S2, using the inclusion from J3S1:
incLJ2S2 : J3S1 -> LJ2S2 = split
  base -> base
  loop1 @ i -> loop1{LJ2S2} @ i
  loop2 @ i j -> loop2{LJ2S2} @ i @ j
  loop3 @ i j k -> loop3{LJ2S2} @ i @ j @ k

problemStep2
  : PROBLEM1
      LJ2S2
      base
      (<i> loop1{LJ2S2} @ i)
      (<i j> loop2{LJ2S2} @ i @ j)
      (<i j> loop2{LJ2S2} @ j @ i) -- flipped!
  = <i j k> mapTr2 J3S1 LJ2S2 incLJ2S2 (problemStep1 @ i @ j @ k)

-- now we only need to flip the loop2 around using loop2Inv, to match
-- our real goal:
problemStep3
  : PROBLEM1
      LJ2S2
      base
      (<i> loop1{LJ2S2} @ i)
      (<i j> loop2{LJ2S2} @ i @ j)
      (<i j> loop2{LJ2S2} @ i @ j) -- flipped back
  = <lol> hcomp
            (Path (Path (tr2 LJ2S2) (inc base) (inc base))
                  (SIDE LJ2S2 base (<i> loop1{LJ2S2} @ i))
                  (SIDE LJ2S2 base (<i> loop1{LJ2S2} @ i)))
            (BIG LJ2S2 base
                 (<i> loop1{LJ2S2} @ i)
                 (<i j> loop2{LJ2S2} @ i @ j)
                 (<i j> loop2Inv{LJ2S2} @ lol @ i @ j))
            [ (lol=0) -> <_> BIG LJ2S2 base
                             (<i> loop1{LJ2S2} @ i)
                             (<i j> loop2{LJ2S2} @ i @ j)
                             (<i j> loop2{LJ2S2} @ i @ j)
            , (lol=1) -> <lol> problemStep2 @ lol
            ]

-- this does give us a solution to the actual problem on LJ2S2:
problem1Base : Problem (tr2 LJ2S2) loopsLJ2S2 (inc base)
  = problemStep3

-- the rest of the full solution is trivial by hlevel:
problem1' : (x : LJ2S2) -> Problem (tr2 LJ2S2) loopsLJ2S2 (inc x) = split
  base -> problem1Base
  -- TODO all trivial by hlevel :(
  loop1 @ i -> TODO @ i
    where
    -- TODO by hlevel
    TODO : PathP (<i> Problem (tr2 LJ2S2) loopsLJ2S2 (inc (loop1{LJ2S2} @ i)))
                 problem1Base
                 problem1Base
      = undefined
  loop2 @ i j -> TODO @ i @ j
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> Problem (tr2 LJ2S2) loopsLJ2S2 (inc (loop2{LJ2S2} @ i @ j)))
                            (problem1' (loop1{LJ2S2} @ i))
                            (problem1' (loop1{LJ2S2} @ i)))
                 (<j> problem1' (loop1{LJ2S2} @ j))
                 (<j> problem1' (loop1{LJ2S2} @ j))
      = undefined
  loop3 @ i j k -> TODO @ i @ j @ k
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> Problem (tr2 LJ2S2) loopsLJ2S2 (inc (loop3{LJ2S2} @ i @ j @ k)))
                                       (problem1' (loop2{LJ2S2} @ i @ j))
                                       (problem1' (loop2{LJ2S2} @ i @ j)))
                            (<k> problem1' (loop2{LJ2S2} @ i @ k))
                            (<k> problem1' (loop2{LJ2S2} @ i @ k)))
                 (<j k> problem1' (loop2{LJ2S2} @ j @ k))
                 (<j k> problem1' (loop2{LJ2S2} @ j @ k))
      = undefined
  loop2Inv @ k i j -> TODO @ k @ i @ j
    where
    -- TODO by hlevel
    TODO : PathP (<k> PathP (<i> PathP (<j> Problem (tr2 LJ2S2) loopsLJ2S2 (inc (loop2Inv{LJ2S2} @ k @ i @ j)))
                                       (problem1' (loop1{LJ2S2} @ i))
                                       (problem1' (loop1{LJ2S2} @ i)))
                            (<j> problem1' (loop1{LJ2S2} @ j))
                            (<j> problem1' (loop1{LJ2S2} @ j)))
                 (<i j> problem1' (loop2{LJ2S2} @ i @ j))
                 (<i j> problem1' (loop2{LJ2S2} @ j @ i))
      = undefined

problem1 : (x : tr2 LJ2S2) ->
  Path (Path (Path (tr2 LJ2S2) x x)
             (local (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2) x)
             (local (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2) x))
       (<i j> local (tr2 LJ2S2) (two U (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2) @ i) x @ j)
       (<_ j> local (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2) x @ j)
  = elimTr2 LJ2S2 P TODO problem1'
  where
  P (x : tr2 LJ2S2) : U =
    Path (Path (Path (tr2 LJ2S2) x x)
               (local (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2) x)
               (local (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2) x))
         (<i j> local (tr2 LJ2S2) (two U (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2) @ i) x @ j)
         (<_ j> local (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2) x @ j)

  -- TODO hlevel
  TODO : (x : tr2 LJ2S2) -> twogroupoid (P x)
    = undefined

opaque problem1

-- so we get the problematic 4-cell on LJ2S2 :D

woohoo : fourCell (tr2 LJ2S2) (global (tr2 LJ2S2) loopsLJ2S2)
  = twoTranspLemma2
      (tr2 LJ2S2)
      (global (tr2 LJ2S2) loopsLJ2S2)
      problem1

-- and now we can define the fibration over J2S2
CodeJ2S2' : J2S2 -> TWOGROUPOID = split
  base -> (tr2 LJ2S2, twogroupoidTr2 LJ2S2)
  loop2 @ i j ->
    (global (tr2 LJ2S2) loopsLJ2S2 @ i @ j, TODO @ i @ j)
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> twogroupoid (global (tr2 LJ2S2) loopsLJ2S2 @ i @ j))
                            (twogroupoidTr2 LJ2S2)
                            (twogroupoidTr2 LJ2S2))
                 (<_> twogroupoidTr2 LJ2S2)
                 (<_> twogroupoidTr2 LJ2S2)
      = undefined
  loop4 @ i j a b ->
    (woohoo @ i @ j @ a @ b,
     TODO @ i @ j @ a @ b)
    where
    -- TODO by hlevel
    -- why is it so slow :(
    TODO : PathP (<i> PathP (<j> PathP (<a> PathP (<b> twogroupoid (woohoo @ i @ j @ a @ b))
                                                  (CodeJ2S2' (loop2{J2S2} @ i @ j)).2
                                                  (CodeJ2S2' (loop2{J2S2} @ i @ j)).2)
                                       (<_> (CodeJ2S2' (loop2{J2S2} @ i @ j)).2)
                                       (<_> (CodeJ2S2' (loop2{J2S2} @ i @ j)).2))
                            (<a b> (CodeJ2S2' (loop2{J2S2} @ a @ b)).2)
                            (<a b> (CodeJ2S2' (loop2{J2S2} @ a @ b)).2))
                 (<j a b> (CodeJ2S2' (loop2{J2S2} @ a @ b)).2)
                 (<j a b> (CodeJ2S2' (loop2{J2S2} @ a @ b)).2)
      = undefined

CodeJ2S2 : tr3 J2S2 -> TWOGROUPOID
  = recTr3 J2S2 TWOGROUPOID
      threegroupoidTWOGROUPOID
      CodeJ2S2'

hard (p : Path (tr3 J2S2) (inc base) (inc base)) : tr2 LJ2S2 =
  transGen (<i> (CodeJ2S2 (p @ i)).1) 0 (inc base)

-- OK! That was the hard part. Now we just need to do:
--
--     pi2 LJ2S2 -> pi2 K(Z/2Z, 2) -> Z/2Z
--
-- This time I will do something more standard-ish, though it would be
-- interesting to try something more like the pi2S2 approach above,
-- using "JS1mod2" which should be the loop space of S2mod2?

data S2mod2
  = base
  | loop2 <a b>
    [ (a=0) -> base
    , (a=1) -> base
    , (b=0) -> base
    , (b=1) -> base
    ]
  | loop2Inv <a b c>
    [ (a=0) -> loop2{S2mod2} @ b @ c
    , (a=1) -> loop2{S2mod2} @ c @ b -- !
    , (b=0) -> base
    , (b=1) -> base
    , (c=0) -> base
    , (c=1) -> base
    ]

-- This is analogous to the map J3S1 -> S2. Does it similarly induce
-- an equivalence tr2 LJ2S2 ~= tr1 rp2 x tr2 S2mod2 ??? is tr2 S2mod2
-- the 1-connected cover of tr2 LJ2S2?

writheMod2 : LJ2S2 -> S2mod2 = split
  base -> base
  loop1 @ i -> base
  loop2 @ i j -> loop2{S2mod2} @ i @ j
  loop3 @ i j k ->
    ccube S2mod2 base (<i j> loop2{S2mod2} @ i @ j) @ i @ j @ k
  loop2Inv @ k i j -> loop2Inv{S2mod2} @ k @ i @ j

data rp2
  = base
  | loop <i> [(i=0) -> base, (i=1) -> base]
  | loopInv <i j> [ (i=0) -> loop{rp2} @ j
                  , (i=1) -> loop{rp2} @ -j
                  , (j=0) -> base
                  , (j=1) -> base
                  ]

modConstSquare
  : PathP (<i> Path rp2 (loop{rp2} @ i) (loop{rp2} @ i))
          (<j> loop{rp2} @ j)
          (<j> loop{rp2} @ j)
  = csq rp2 base base base (<i> loop{rp2} @ i) (<i> loop{rp2} @ i) (<__ > base)

-- TODO by hlevel
TODO_modCube
  : PathP (<i> PathP (<j> Path (tr1 rp2)
                               (inc (loopInv{rp2} @ i @ j))
                               (inc (loopInv{rp2} @ i @ j)))
                     (<k> inc (loop{rp2} @ k))
                     (<k> inc (loop{rp2} @ k)))
          (<j k> inc (modConstSquare @ j @ k))
          (<j k> inc (modConstSquare @ -j @ k))
  = undefined

rot2' : (x : rp2) -> Path (tr1 rp2) (inc x) (inc x) = split
  base -> <k> inc (loop{rp2} @ k)
  loop @ i -> <k> inc (modConstSquare @ i @ k)
  loopInv @ i j -> <k> TODO_modCube @ i @ j @ k

rot2 : (x : tr1 rp2) -> Path (tr1 rp2) x x
  = elimTr1 rp2 (\(x : tr1 rp2) -> Path (tr1 rp2) x x)
      TODO
      rot2'
  where
  -- TODO hlevel
  TODO : (x : tr1 rp2) -> groupoid (Path (tr1 rp2) x x)
    = undefined

rot2Flip (x : tr1 rp2) : Path (tr1 rp2) x x =
  <i> rot2 x @ -i

ROT2 : Global (tr1 rp2) = global (tr1 rp2) rot2

ROT2FLIP : Global (tr1 rp2) = <i j> ROT2 @ j @ i

-- TODO by hlevel
TODO_transposeROT2_mod
  : PathP (<i> PathP (<j> Path (Path (tr1 rp2)
                                     (inc (loopInv{rp2} @ i @ j))
                                     (inc (loopInv{rp2} @ i @ j)))
                               (rot2 (inc (loopInv{rp2} @ i @ j)))
                               (rot2Flip (inc (loopInv{rp2} @ i @ j))))
                     (<k l> inc (loopInv{rp2} @ k @ l))
                     (<k l> inc (loopInv{rp2} @ k @ l)))
          (<j k l> TODO_modCube @ k @ l @ j)
          (<j k l> TODO_modCube @ k @ l @ -j)
  = undefined

transposeROT2_step1'
  : (x : rp2) -> Path (Path (tr1 rp2) (inc x) (inc x))
                      (rot2 (inc x))
                      (rot2Flip (inc x))
  = split
  base -> <i j> inc (loopInv{rp2} @ i @ j)
  loop @ i -> <j k> TODO_modCube @ j @ k @ i
  loopInv @ i j -> TODO_transposeROT2_mod @ i @ j

transposeROT2_step1 : (x : tr1 rp2) -> Path (Path (tr1 rp2) x x) (rot2 x) (rot2Flip x)
  = elimTr1 rp2
      (\(x : tr1 rp2) -> Path (Path (tr1 rp2) x x) (rot2 x) (rot2Flip x))
      TODO
      transposeROT2_step1'
  where
  -- TODO hlevel
  TODO : (x : tr1 rp2) -> groupoid (Path (Path (tr1 rp2) x x) (rot2 x) (rot2Flip x))
    = undefined

hcompInv (A : U) (x y : A) (p : Path A x y) : Path A y x
  = <i> hcomp A x [(i = 0) -> p, (i = 1) -> <_> x]

hcompNudge (A : U) (x y : A) (p : Path A x y) : Path A x y
  = <i> hcomp A (p @ i) [(i = 0) -> <_> x, (i = 1) -> <_> y]

STEP3 (x : rp2) : U =
  Path (Path (tr1 rp2) (inc x) (inc x))
       (<i> hcomp (tr1 rp2)
                  (hcomp (tr1 rp2)
                         (transGen (<_> tr1 rp2) 0 (rot2' x @ i))
                         [ (i=0) -> <_> inc x
                         , (i=1) -> <_> inc x
                         ])
                  [ (i=0) -> <_> inc x
                  , (i=1) -> <_> inc x
                  ])
       (<i> hcomp (tr1 rp2)
                  (hcomp (tr1 rp2)
                         (inc x)
                         [ (i=0) -> <i> transGen (<_> tr1 rp2) i (rot2' x @ i)
                         , (i=1) -> <_> inc x
                         ])
                  [ (i=0) -> <_> inc x
                  , (i=1) -> <_> inc x
                  ])

step3base
  -- : STEP3 base
  : Path (Path (tr1 rp2) (inc base) (inc base))
         (<j> hcompNudge (tr1 rp2) (inc base) (inc base)
                (hcompNudge (tr1 rp2) (inc base) (inc base)
                  (rot2 (inc base)))
                @ j)
         (<j> hcompNudge (tr1 rp2) (inc base) (inc base)
                (hcompInv (tr1 rp2) (inc base) (inc base)
                  (rot2 (inc base)))
                @ j)
  -- TODO easy
  = undefined

transposeROT2_step3''
  : (x : rp2) -> STEP3 x
  = split
  base -> step3base
  loop @ i -> TODO @ i
    where
    -- TODO by hlevel
    TODO : PathP (<i> STEP3 (loop{rp2} @ i)) step3base step3base
      = undefined
  loopInv @ i j -> TODO @ i @ j
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> STEP3 (loopInv{rp2} @ i @ j))
                            (transposeROT2_step3'' base)
                            (transposeROT2_step3'' base))
                 (<j> transposeROT2_step3'' (loop{rp2} @ j))
                 (<j> transposeROT2_step3'' (loop{rp2} @ -j))
      = undefined

transposeROT2_step3'
  : (x : tr1 rp2) ->
    Path (Path (tr1 rp2) x x)
         (local (tr1 rp2) ROT2 x)
         (local (tr1 rp2) ROT2FLIP x)
  = elimTr1 rp2
      (\(x : tr1 rp2) -> Path (Path (tr1 rp2) x x)
                              (local (tr1 rp2) ROT2 x)
                              (local (tr1 rp2) ROT2FLIP x))
      TODO
      transposeROT2_step3''
  where
  TODO : (x : tr1 rp2) -> groupoid (Path (Path (tr1 rp2) x x)
                                         (local (tr1 rp2) ROT2 x)
                                         (local (tr1 rp2) ROT2FLIP x))
    = undefined

transposeROT2_step3
  : Path (Path (tr1 rp2 -> tr1 rp2)
               (idfun (tr1 rp2))
               (idfun (tr1 rp2)))
         (local' (tr1 rp2) ROT2)
         (local' (tr1 rp2) ROT2FLIP)
  = <i j> \(x : tr1 rp2) -> transposeROT2_step3' x @ i @ j

transposeROT2 : Path (Global (tr1 rp2)) ROT2 ROT2FLIP =
  globalEq (tr1 rp2) ROT2 ROT2FLIP transposeROT2_step3

rp2_groupoid : groupoid (tr1 rp2) = groupoidTr1 rp2

-- TODO by hlevel
TODO_ROT2_groupoid : PathP (<i> PathP (<j> groupoid (ROT2 @ i @ j)) rp2_groupoid rp2_groupoid)
                           (<_> rp2_groupoid)
                           (<_> rp2_groupoid)
  = undefined

F4'' : S2mod2 -> GROUPOID = split
  base -> (tr1 rp2, rp2_groupoid)
  loop2 @ i j -> (ROT2 @ i @ j, TODO_ROT2_groupoid @ i @ j)
  loop2Inv @ k i j -> rem @ k @ i @ j
    where
    -- TODO by hlevel
    TODO : PathP (<k> PathP (<i> PathP (<j> groupoid (transposeROT2 @ k @ i @ j))
                                       (rp2_groupoid)
                                       (rp2_groupoid))
                            (<_> rp2_groupoid)
                            (<_> rp2_groupoid))
                 (<i j> TODO_ROT2_groupoid @ i @ j)
                 (<i j> TODO_ROT2_groupoid @ j @ i)
      = undefined

    rem : PathP (<k> PathP (<i> PathP (<j> GROUPOID)
                                      (tr1 rp2, rp2_groupoid)
                                      (tr1 rp2, rp2_groupoid))
                           (<_> (tr1 rp2, rp2_groupoid))
                           (<_> (tr1 rp2, rp2_groupoid)))
                (<i j> (ROT2 @ i @ j, TODO_ROT2_groupoid @ i @ j))
                (<i j> (ROT2 @ j @ i, TODO_ROT2_groupoid @ j @ i))
      = <k i j> (transposeROT2 @ k @ i @ j, TODO @ k @ i @ j)

F4' : tr2 S2mod2 -> GROUPOID
  = recTr2 S2mod2 GROUPOID twogroupoidGROUPOID
      F4''

F4 (y : tr2 S2mod2) : U = (F4' y).1

f4 (p : Path (Path (tr2 S2mod2) (inc base) (inc base)) (<_> inc base) (<_> inc base))
  : Path (tr1 rp2) (inc base) (inc base) =
  local (tr1 rp2) (<i j> F4 (p @ i @ j)) (inc base)

-- TODO easy
TODO_codeBaut2_mod : Path (Path U bool bool) negbPath (<i> negbPath @ -i)
  = undefined

codeBaut2' : rp2 -> SET = split
  base -> (bool, setBool)
  loop @ i -> (negbPath @ i, TODO @ i)
    where
    -- TODO by hlevel
    TODO : PathP (<i> set (negbPath @ i)) setBool setBool
      = undefined
  loopInv @ i j -> (TODO_codeBaut2_mod @ i @ j, TODO @ i @ j)
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> set (TODO_codeBaut2_mod @ i @ j)) setBool setBool)
                 (<j> (codeBaut2' (loop{rp2} @ j)).2)
                 (<j> (codeBaut2' (loop{rp2} @ -j)).2)
      = undefined

codeBaut2 : tr1 rp2 -> SET
  = recTr1 rp2 SET
      groupoidSET
      codeBaut2'

windingBaut2 (p : Path (tr1 rp2) (inc base) (inc base)) : bool
  = transGen (<i> (codeBaut2 (p @ i)).1) 0 false

wrappingS2mod2
  (p : Path (Path (tr2 S2mod2) (inc base) (inc base)) (<_> inc base) (<_> inc base))
  : bool
  = windingBaut2 (f4 p)

wrappingLJ2S2
  (p : Path (Path (tr2 LJ2S2) (inc base) (inc base)) (<_> inc base) (<_> inc base))
  : bool
  = wrappingS2mod2 (<i j> mapTr2 LJ2S2 S2mod2 writheMod2 (p @ i @ j))

wrappingJ2S2
  (p : Path (Path (Path (tr3 J2S2) (inc base) (inc base)) (<_> inc base) (<_> inc base)) (<_ _> inc base) (<_ _> inc base))
  : bool
  = wrappingLJ2S2 (<i j> hard (p @ i @ j))



data JS2
  = base
  | loops (x : JS2) <i j> [ (i=0) -> x
                          , (i=1) -> x
                          , (j=0) -> x
                          , (j=1) -> x
                          ]

loopsJ2S2' : (x : J2S2) -> Path (Path (tr3 J2S2) (inc x) (inc x)) (<_> inc x) (<_> inc x) = split
  base -> <i j> inc (loop2{J2S2} @ i @ j)
  loop2 @ i j -> <k l> inc (loop4{J2S2} @ i @ j @ k @ l)
  loop4 @ i j k l -> TODO @ i @ j @ k @ l
    where
    -- TODO by hlevel
    TODO : PathP (<i> PathP (<j> PathP (<k> PathP (<l> Path (Path (tr3 J2S2)
                                                                  (inc (loop4{J2S2} @ i @ j @ k @ l))
                                                                  (inc (loop4{J2S2} @ i @ j @ k @ l)))
                                                            (<_> inc (loop4{J2S2} @ i @ j @ k @ l))
                                                            (<_> inc (loop4{J2S2} @ i @ j @ k @ l)))
                                                  (<m n> inc (loop4{J2S2} @ i @ j @ m @ n))
                                                  (<m n> inc (loop4{J2S2} @ i @ j @ m @ n)))
                                       (<l m n> inc (loop4{J2S2} @ i @ j @ m @ n))
                                       (<l m n> inc (loop4{J2S2} @ i @ j @ m @ n)))
                            (<k l m n> inc (loop4{J2S2} @ k @ l @ m @ n))
                            (<k l m n> inc (loop4{J2S2} @ k @ l @ m @ n)))
                 (<j k l m n> inc (loop4{J2S2} @ k @ l @ m @ n))
                 (<j k l m n> inc (loop4{J2S2} @ k @ l @ m @ n))
      = undefined

loopsJ2S2 : (x : tr3 J2S2) -> Path (Path (tr3 J2S2) x x) (<_> x) (<_> x)
  = elimTr3 J2S2
      (\(x : tr3 J2S2) -> Path (Path (tr3 J2S2) x x) (<_> x) (<_> x))
      TODO
      loopsJ2S2'
  where
  -- TODO by hlevel
  TODO : (x : tr3 J2S2) -> threegroupoid (Path (Path (tr3 J2S2) x x) (<_> x) (<_> x))
    = undefined

j2s2 : JS2 -> tr3 J2S2 = split
  base -> inc base
  loops x @ i j ->
    loopsJ2S2 (j2s2 x) @ i @j

wrappingJS2
  (p : Path (Path (Path JS2 base base) (<_> base) (<_> base)) (<_ _> base) (<_ _> base))
  : bool
  = wrappingJ2S2 (<i j k> j2s2 (p @ i @ j @ k))



data S3
  = base
  | loop3 <i j k>
    [ (i=0) -> base
    , (i=1) -> base
    , (j=0) -> base
    , (j=1) -> base
    , (k=0) -> base
    , (k=1) -> base
    ]

rot3 (A : U) (h : (x : A) -> Path (Path A x x) (<_> x) (<_> x)) : Path (Path (A -> A) (idfun A) (idfun A)) (<_> idfun A) (<_> idfun A)
  = <i j> \(x : A) -> h x @ i @ j

-- TODO there must be a better way
rot3IsEquiv (A : U) (h : (x : A) -> Path (Path A x x) (<_> x) (<_> x))
  : PathP (<i> PathP (<j> isEquiv A A (rot3 A h @ i @ j)) (idIsEquiv A) (idIsEquiv A)) (<_> idIsEquiv A) (<_> idIsEquiv A)
  = lemPropF'
      (Path (A -> A) (idfun A) (idfun A))
      (\(f : Path (A -> A) (idfun A) (idfun A)) -> PathP (<j> isEquiv A A (f @ j)) (idIsEquiv A) (idIsEquiv A))
      hole2
      (<_> idfun A) (<_> idfun A)
      (rot3 A h)
      (<_> idIsEquiv A)
      (<_> idIsEquiv A)
  where
  ugh (A B : U) (P : Path U A B) (x : A) (y : B) : Path U (PathP (<i> P @ i) x y) (Path B (transGen (<i> P @ i) 0 x) y)
    = <k> PathP (<i> P @ i \/ k) (transGen (<i> P @ i /\ k) -k x) y

  hole1 (f : Path (A -> A) (idfun A) (idfun A))
    : prop (Path (isEquiv A A (idfun A)) (transGen (<i> isEquiv A A (f @ i)) 0 (idIsEquiv A)) (idIsEquiv A))
    = propSet (isEquiv A A (idfun A))
        (propIsEquivDirect' A A (idfun A))
        (transGen (<i> isEquiv A A (f @ i)) 0 (idIsEquiv A))
        (idIsEquiv A)

  hole2 (f : Path (A -> A) (idfun A) (idfun A))
    : prop (PathP (<j> isEquiv A A (f @ j)) (idIsEquiv A) (idIsEquiv A))
    = transGen (<i> prop (ugh (isEquiv A A (idfun A)) (isEquiv A A (idfun A)) (<j> isEquiv A A (f @ j)) (idIsEquiv A) (idIsEquiv A) @ -i))
               0
               (hole1 f)

Global3 (A : U) : U = Path (Path (Path U A A) (<_> A) (<_> A)) (<_ _> A) (<_ _> A)

global3 (A : U) (h : (x : A) -> Path (Path A x x) (<_> x) (<_> x)) : Global3 A =
  <i j k> Glue A [ (i=0) -> (A, idEquiv A)
                 , (i=1) -> (A, idEquiv A)
                 , (j=0) -> (A, idEquiv A)
                 , (j=1) -> (A, idEquiv A)
                 , (k=0) -> (A, rot3 A h @ i @ j, rot3IsEquiv A h @ i @ j)
                 , (k=1) -> (A, idEquiv A)
                 ]

CodeS3 : S3 -> U = split
  base -> JS2
  loop3 @ i j k -> global3 JS2 (\(x : JS2) -> <i j> loops{JS2} x @ i @ j) @ i @ j @ k

js2' (x : S3) (p : Path S3 base x) : CodeS3 x
  = transGen (<i> CodeS3 (p @ i)) 0 base

js2 (p : Path S3 base base) : JS2 = js2' base p

O4S3 : U = Path (Path (Path (Path S3 base base) (<_> base) (<_> base)) (<_ _> base) (<_ _> base)) (<_ _ _> base) (<_ _ _> base)

wrappingS3 (p : O4S3) : bool
  = wrappingJS2 (<i j k> js2 (p @ i @ j @ k))

-- Now we must plug in a generator of pi4S3. We can get it from the
-- "cubical Eckmann-Hilton generator" for pi3S2:

oneThing (A : U) (x : A) (p : Path (Path A x x) (<_> x) (<_> x))
  : PathP (<i> Path (Path A x x) (<k> p @ i @ k) (<k> p @ i @ k)) p p
  = <j a b> hcomp A (p @ j @ b)
                  [ (j=0) -> <f> p @ a @ b /\ f
                  , (j=1) -> <f> p @ a @ b /\ f
                  , (a=0) -> <f> p @ j @ b
                  , (a=1) -> <f> p @ j @ b
                  , (b=0) -> <f> x
                  , (b=1) -> <f> p @ a @ f
                  ]

oneThingy (A : U) (x : A) (p : Path (Path A x x) (<_> x) (<_> x))
  : Path (Path (Path A x x) (<_> x) (<_> x)) (<_ _> x) (<_ _> x)
  = csqInv (Path A x x) (<_> x) (<_> x) (<_> x) p p
      (oneThing A x p)

genPi4s3 : O4S3
  = oneThingy (Path S3 base base) (<_> base) (<i j k> loop3{S3} @ i @ j @ k)

whew : bool
  = wrappingS3 genPi4s3

-- > :n whew
-- NORMEVAL: true
-- #hcomps: 0
-- Time: 3m6.889s

-- This seems to use significantly more time and memory than my first
-- attempt...

conclusion (h : Path O4S3 (<_ _ _ _> base) genPi4s3) : N0
  = transGen (<i> P (wrappingS3 (h @ -i))) 0 true
  where
  P : bool -> U = split
    false -> N0
    true -> bool
